Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> PROGRAM IDENT SEMICOLON outblock PERIOD
Rule 2     outblock -> var_decl_part subprog_decl_part outblock_act statement
Rule 3     outblock_act -> <empty>
Rule 4     var_decl_part -> var_decl_list SEMICOLON
Rule 5     var_decl_part -> <empty>
Rule 6     var_decl_list -> var_decl_list SEMICOLON var_decl
Rule 7     var_decl_list -> var_decl
Rule 8     var_decl -> VAR id_list
Rule 9     subprog_decl_part -> subprog_decl_list SEMICOLON
Rule 10    subprog_decl_part -> <empty>
Rule 11    subprog_decl_list -> subprog_decl_list SEMICOLON subprog_decl
Rule 12    subprog_decl_list -> subprog_decl
Rule 13    subprog_decl -> proc_decl
Rule 14    subprog_decl -> func_decl
Rule 15    proc_decl -> PROCEDURE proc_name LPAREN RPAREN SEMICOLON inblock
Rule 16    proc_decl -> PROCEDURE proc_name LPAREN proc_decl_act1 id_list RPAREN SEMICOLON inblock
Rule 17    proc_decl_act1 -> <empty>
Rule 18    proc_name -> IDENT
Rule 19    inblock -> inblock_act1 var_decl_part inblock_act2 statement
Rule 20    inblock_act1 -> <empty>
Rule 21    inblock_act2 -> <empty>
Rule 22    func_decl -> FUNCTION func_name LPAREN RPAREN SEMICOLON func_inblock
Rule 23    func_decl -> FUNCTION func_name LPAREN func_decl_act1 id_list RPAREN SEMICOLON func_inblock
Rule 24    func_decl_act1 -> <empty>
Rule 25    func_name -> IDENT
Rule 26    func_inblock -> func_inblock_act1 var_decl_part func_inblock_act2 statement
Rule 27    func_inblock_act1 -> <empty>
Rule 28    func_inblock_act2 -> <empty>
Rule 29    statement_list -> statement_list SEMICOLON statement
Rule 30    statement_list -> statement
Rule 31    statement -> assignment_statement
Rule 32    statement -> if_statement
Rule 33    statement -> while_statement
Rule 34    statement -> for_statement
Rule 35    statement -> proc_call_statement
Rule 36    statement -> null_statement
Rule 37    statement -> block_statement
Rule 38    statement -> read_statement
Rule 39    statement -> write_statement
Rule 40    statement -> func_call_statement
Rule 41    assignment_statement -> IDENT ASSIGN expression
Rule 42    assignment_statement -> IDENT LBRACKET expression RBRACKET ASSIGN expression
Rule 43    if_statement -> IF condition if_act1 THEN statement else_statement
Rule 44    if_act1 -> <empty>
Rule 45    else_statement -> ELSE else_act1 statement
Rule 46    else_statement -> <empty>
Rule 47    else_act1 -> <empty>
Rule 48    while_statement -> WHILE while_act1 condition while_act2 DO statement
Rule 49    while_act1 -> <empty>
Rule 50    while_act2 -> <empty>
Rule 51    for_statement -> FOR IDENT ASSIGN expression TO expression for_act1 DO statement
Rule 52    for_act1 -> <empty>
Rule 53    proc_call_statement -> proc_call_name LPAREN RPAREN
Rule 54    proc_call_statement -> proc_call_name LPAREN proc_call_statement_act1 arg_list RPAREN
Rule 55    proc_call_statement_act1 -> <empty>
Rule 56    func_call_statement -> func_call_name LPAREN RPAREN
Rule 57    func_call_statement -> func_call_name LPAREN func_call_statement_act1 arg_list RPAREN
Rule 58    func_call_statement_act1 -> <empty>
Rule 59    arg_list -> expression
Rule 60    arg_list -> arg_list COMMA expression
Rule 61    proc_call_name -> IDENT
Rule 62    func_call_name -> IDENT
Rule 63    block_statement -> BEGIN statement_list END
Rule 64    read_statement -> READ LPAREN IDENT RPAREN
Rule 65    read_statement -> READ LPAREN IDENT LBRACKET expression RBRACKET RPAREN
Rule 66    write_statement -> WRITE LPAREN expression RPAREN
Rule 67    null_statement -> <empty>
Rule 68    condition -> expression EQ expression
Rule 69    condition -> expression NEQ expression
Rule 70    condition -> expression LT expression
Rule 71    condition -> expression LE expression
Rule 72    condition -> expression GT expression
Rule 73    condition -> expression GE expression
Rule 74    expression -> term
Rule 75    expression -> MINUS term
Rule 76    expression -> expression PLUS term
Rule 77    expression -> expression MINUS term
Rule 78    expression -> func_call_statement
Rule 79    term -> factor
Rule 80    term -> term MULT factor
Rule 81    term -> term DIV factor
Rule 82    term -> func_call_statement
Rule 83    factor -> var_name
Rule 84    factor -> number
Rule 85    factor -> LPAREN expression RPAREN
Rule 86    factor -> func_call_statement
Rule 87    var_name -> IDENT
Rule 88    var_name -> IDENT LBRACKET expression RBRACKET
Rule 89    number -> NUMBER
Rule 90    id_list -> IDENT
Rule 91    id_list -> id_list COMMA IDENT
Rule 92    id_list -> id_list COMMA IDENT LBRACKET NUMBER INTERVAL NUMBER RBRACKET
Rule 93    id_list -> IDENT LBRACKET NUMBER INTERVAL NUMBER RBRACKET COMMA id_list id_list_act1
Rule 94    id_list_act1 -> <empty>

Terminals, with rules where they appear

ASSIGN               : 41 42 51
BEGIN                : 63
COMMA                : 60 91 92 93
DIV                  : 81
DO                   : 48 51
ELSE                 : 45
END                  : 63
EQ                   : 68
FOR                  : 51
FUNCTION             : 22 23
GE                   : 73
GT                   : 72
IDENT                : 1 18 25 41 42 51 61 62 64 65 87 88 90 91 92 93
IF                   : 43
INTERVAL             : 92 93
LBRACKET             : 42 65 88 92 93
LE                   : 71
LPAREN               : 15 16 22 23 53 54 56 57 64 65 66 85
LT                   : 70
MINUS                : 75 77
MULT                 : 80
NEQ                  : 69
NUMBER               : 89 92 92 93 93
PERIOD               : 1
PLUS                 : 76
PROCEDURE            : 15 16
PROGRAM              : 1
RBRACKET             : 42 65 88 92 93
READ                 : 64 65
RPAREN               : 15 16 22 23 53 54 56 57 64 65 66 85
SEMICOLON            : 1 4 6 9 11 15 16 22 23 29
THEN                 : 43
TO                   : 51
VAR                  : 8
WHILE                : 48
WRITE                : 66
error                : 

Nonterminals, with rules where they appear

arg_list             : 54 57 60
assignment_statement : 31
block_statement      : 37
condition            : 43 48
else_act1            : 45
else_statement       : 43
expression           : 41 42 42 51 51 59 60 65 66 68 68 69 69 70 70 71 71 72 72 73 73 76 77 85 88
factor               : 79 80 81
for_act1             : 51
for_statement        : 34
func_call_name       : 56 57
func_call_statement  : 40 78 82 86
func_call_statement_act1 : 57
func_decl            : 14
func_decl_act1       : 23
func_inblock         : 22 23
func_inblock_act1    : 26
func_inblock_act2    : 26
func_name            : 22 23
id_list              : 8 16 23 91 92 93
id_list_act1         : 93
if_act1              : 43
if_statement         : 32
inblock              : 15 16
inblock_act1         : 19
inblock_act2         : 19
null_statement       : 36
number               : 84
outblock             : 1
outblock_act         : 2
proc_call_name       : 53 54
proc_call_statement  : 35
proc_call_statement_act1 : 54
proc_decl            : 13
proc_decl_act1       : 16
proc_name            : 15 16
program              : 0
read_statement       : 38
statement            : 2 19 26 29 30 43 45 48 51
statement_list       : 29 63
subprog_decl         : 11 12
subprog_decl_list    : 9 11
subprog_decl_part    : 2
term                 : 74 75 76 77 80 81
var_decl             : 6 7
var_decl_list        : 4 6
var_decl_part        : 2 19 26
var_name             : 83
while_act1           : 48
while_act2           : 48
while_statement      : 33
write_statement      : 39

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . PROGRAM IDENT SEMICOLON outblock PERIOD

    PROGRAM         shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> PROGRAM . IDENT SEMICOLON outblock PERIOD

    IDENT           shift and go to state 3


state 3

    (1) program -> PROGRAM IDENT . SEMICOLON outblock PERIOD

    SEMICOLON       shift and go to state 4


state 4

    (1) program -> PROGRAM IDENT SEMICOLON . outblock PERIOD
    (2) outblock -> . var_decl_part subprog_decl_part outblock_act statement
    (4) var_decl_part -> . var_decl_list SEMICOLON
    (5) var_decl_part -> .
    (6) var_decl_list -> . var_decl_list SEMICOLON var_decl
    (7) var_decl_list -> . var_decl
    (8) var_decl -> . VAR id_list

    PROCEDURE       reduce using rule 5 (var_decl_part -> .)
    FUNCTION        reduce using rule 5 (var_decl_part -> .)
    IDENT           reduce using rule 5 (var_decl_part -> .)
    IF              reduce using rule 5 (var_decl_part -> .)
    WHILE           reduce using rule 5 (var_decl_part -> .)
    FOR             reduce using rule 5 (var_decl_part -> .)
    BEGIN           reduce using rule 5 (var_decl_part -> .)
    READ            reduce using rule 5 (var_decl_part -> .)
    WRITE           reduce using rule 5 (var_decl_part -> .)
    PERIOD          reduce using rule 5 (var_decl_part -> .)
    VAR             shift and go to state 9

    outblock                       shift and go to state 5
    var_decl_part                  shift and go to state 6
    var_decl_list                  shift and go to state 7
    var_decl                       shift and go to state 8

state 5

    (1) program -> PROGRAM IDENT SEMICOLON outblock . PERIOD

    PERIOD          shift and go to state 10


state 6

    (2) outblock -> var_decl_part . subprog_decl_part outblock_act statement
    (9) subprog_decl_part -> . subprog_decl_list SEMICOLON
    (10) subprog_decl_part -> .
    (11) subprog_decl_list -> . subprog_decl_list SEMICOLON subprog_decl
    (12) subprog_decl_list -> . subprog_decl
    (13) subprog_decl -> . proc_decl
    (14) subprog_decl -> . func_decl
    (15) proc_decl -> . PROCEDURE proc_name LPAREN RPAREN SEMICOLON inblock
    (16) proc_decl -> . PROCEDURE proc_name LPAREN proc_decl_act1 id_list RPAREN SEMICOLON inblock
    (22) func_decl -> . FUNCTION func_name LPAREN RPAREN SEMICOLON func_inblock
    (23) func_decl -> . FUNCTION func_name LPAREN func_decl_act1 id_list RPAREN SEMICOLON func_inblock

    IDENT           reduce using rule 10 (subprog_decl_part -> .)
    IF              reduce using rule 10 (subprog_decl_part -> .)
    WHILE           reduce using rule 10 (subprog_decl_part -> .)
    FOR             reduce using rule 10 (subprog_decl_part -> .)
    BEGIN           reduce using rule 10 (subprog_decl_part -> .)
    READ            reduce using rule 10 (subprog_decl_part -> .)
    WRITE           reduce using rule 10 (subprog_decl_part -> .)
    PERIOD          reduce using rule 10 (subprog_decl_part -> .)
    PROCEDURE       shift and go to state 16
    FUNCTION        shift and go to state 17

    subprog_decl_part              shift and go to state 11
    subprog_decl_list              shift and go to state 12
    subprog_decl                   shift and go to state 13
    proc_decl                      shift and go to state 14
    func_decl                      shift and go to state 15

state 7

    (4) var_decl_part -> var_decl_list . SEMICOLON
    (6) var_decl_list -> var_decl_list . SEMICOLON var_decl

    SEMICOLON       shift and go to state 18


state 8

    (7) var_decl_list -> var_decl .

    SEMICOLON       reduce using rule 7 (var_decl_list -> var_decl .)


state 9

    (8) var_decl -> VAR . id_list
    (90) id_list -> . IDENT
    (91) id_list -> . id_list COMMA IDENT
    (92) id_list -> . id_list COMMA IDENT LBRACKET NUMBER INTERVAL NUMBER RBRACKET
    (93) id_list -> . IDENT LBRACKET NUMBER INTERVAL NUMBER RBRACKET COMMA id_list id_list_act1

    IDENT           shift and go to state 20

    id_list                        shift and go to state 19

state 10

    (1) program -> PROGRAM IDENT SEMICOLON outblock PERIOD .

    $end            reduce using rule 1 (program -> PROGRAM IDENT SEMICOLON outblock PERIOD .)


state 11

    (2) outblock -> var_decl_part subprog_decl_part . outblock_act statement
    (3) outblock_act -> .

    IDENT           reduce using rule 3 (outblock_act -> .)
    IF              reduce using rule 3 (outblock_act -> .)
    WHILE           reduce using rule 3 (outblock_act -> .)
    FOR             reduce using rule 3 (outblock_act -> .)
    BEGIN           reduce using rule 3 (outblock_act -> .)
    READ            reduce using rule 3 (outblock_act -> .)
    WRITE           reduce using rule 3 (outblock_act -> .)
    PERIOD          reduce using rule 3 (outblock_act -> .)

    outblock_act                   shift and go to state 21

state 12

    (9) subprog_decl_part -> subprog_decl_list . SEMICOLON
    (11) subprog_decl_list -> subprog_decl_list . SEMICOLON subprog_decl

    SEMICOLON       shift and go to state 22


state 13

    (12) subprog_decl_list -> subprog_decl .

    SEMICOLON       reduce using rule 12 (subprog_decl_list -> subprog_decl .)


state 14

    (13) subprog_decl -> proc_decl .

    SEMICOLON       reduce using rule 13 (subprog_decl -> proc_decl .)


state 15

    (14) subprog_decl -> func_decl .

    SEMICOLON       reduce using rule 14 (subprog_decl -> func_decl .)


state 16

    (15) proc_decl -> PROCEDURE . proc_name LPAREN RPAREN SEMICOLON inblock
    (16) proc_decl -> PROCEDURE . proc_name LPAREN proc_decl_act1 id_list RPAREN SEMICOLON inblock
    (18) proc_name -> . IDENT

    IDENT           shift and go to state 24

    proc_name                      shift and go to state 23

state 17

    (22) func_decl -> FUNCTION . func_name LPAREN RPAREN SEMICOLON func_inblock
    (23) func_decl -> FUNCTION . func_name LPAREN func_decl_act1 id_list RPAREN SEMICOLON func_inblock
    (25) func_name -> . IDENT

    IDENT           shift and go to state 26

    func_name                      shift and go to state 25

state 18

    (4) var_decl_part -> var_decl_list SEMICOLON .
    (6) var_decl_list -> var_decl_list SEMICOLON . var_decl
    (8) var_decl -> . VAR id_list

    PROCEDURE       reduce using rule 4 (var_decl_part -> var_decl_list SEMICOLON .)
    FUNCTION        reduce using rule 4 (var_decl_part -> var_decl_list SEMICOLON .)
    IDENT           reduce using rule 4 (var_decl_part -> var_decl_list SEMICOLON .)
    IF              reduce using rule 4 (var_decl_part -> var_decl_list SEMICOLON .)
    WHILE           reduce using rule 4 (var_decl_part -> var_decl_list SEMICOLON .)
    FOR             reduce using rule 4 (var_decl_part -> var_decl_list SEMICOLON .)
    BEGIN           reduce using rule 4 (var_decl_part -> var_decl_list SEMICOLON .)
    READ            reduce using rule 4 (var_decl_part -> var_decl_list SEMICOLON .)
    WRITE           reduce using rule 4 (var_decl_part -> var_decl_list SEMICOLON .)
    PERIOD          reduce using rule 4 (var_decl_part -> var_decl_list SEMICOLON .)
    SEMICOLON       reduce using rule 4 (var_decl_part -> var_decl_list SEMICOLON .)
    VAR             shift and go to state 9

    var_decl                       shift and go to state 27

state 19

    (8) var_decl -> VAR id_list .
    (91) id_list -> id_list . COMMA IDENT
    (92) id_list -> id_list . COMMA IDENT LBRACKET NUMBER INTERVAL NUMBER RBRACKET

    SEMICOLON       reduce using rule 8 (var_decl -> VAR id_list .)
    COMMA           shift and go to state 28


state 20

    (90) id_list -> IDENT .
    (93) id_list -> IDENT . LBRACKET NUMBER INTERVAL NUMBER RBRACKET COMMA id_list id_list_act1

    COMMA           reduce using rule 90 (id_list -> IDENT .)
    SEMICOLON       reduce using rule 90 (id_list -> IDENT .)
    RPAREN          reduce using rule 90 (id_list -> IDENT .)
    LBRACKET        shift and go to state 29


state 21

    (2) outblock -> var_decl_part subprog_decl_part outblock_act . statement
    (31) statement -> . assignment_statement
    (32) statement -> . if_statement
    (33) statement -> . while_statement
    (34) statement -> . for_statement
    (35) statement -> . proc_call_statement
    (36) statement -> . null_statement
    (37) statement -> . block_statement
    (38) statement -> . read_statement
    (39) statement -> . write_statement
    (40) statement -> . func_call_statement
    (41) assignment_statement -> . IDENT ASSIGN expression
    (42) assignment_statement -> . IDENT LBRACKET expression RBRACKET ASSIGN expression
    (43) if_statement -> . IF condition if_act1 THEN statement else_statement
    (48) while_statement -> . WHILE while_act1 condition while_act2 DO statement
    (51) for_statement -> . FOR IDENT ASSIGN expression TO expression for_act1 DO statement
    (53) proc_call_statement -> . proc_call_name LPAREN RPAREN
    (54) proc_call_statement -> . proc_call_name LPAREN proc_call_statement_act1 arg_list RPAREN
    (67) null_statement -> .
    (63) block_statement -> . BEGIN statement_list END
    (64) read_statement -> . READ LPAREN IDENT RPAREN
    (65) read_statement -> . READ LPAREN IDENT LBRACKET expression RBRACKET RPAREN
    (66) write_statement -> . WRITE LPAREN expression RPAREN
    (56) func_call_statement -> . func_call_name LPAREN RPAREN
    (57) func_call_statement -> . func_call_name LPAREN func_call_statement_act1 arg_list RPAREN
    (61) proc_call_name -> . IDENT
    (62) func_call_name -> . IDENT

    IDENT           shift and go to state 41
    IF              shift and go to state 42
    WHILE           shift and go to state 43
    FOR             shift and go to state 44
    PERIOD          reduce using rule 67 (null_statement -> .)
    BEGIN           shift and go to state 46
    READ            shift and go to state 47
    WRITE           shift and go to state 48

    statement                      shift and go to state 30
    assignment_statement           shift and go to state 31
    if_statement                   shift and go to state 32
    while_statement                shift and go to state 33
    for_statement                  shift and go to state 34
    proc_call_statement            shift and go to state 35
    null_statement                 shift and go to state 36
    block_statement                shift and go to state 37
    read_statement                 shift and go to state 38
    write_statement                shift and go to state 39
    func_call_statement            shift and go to state 40
    proc_call_name                 shift and go to state 45
    func_call_name                 shift and go to state 49

state 22

    (9) subprog_decl_part -> subprog_decl_list SEMICOLON .
    (11) subprog_decl_list -> subprog_decl_list SEMICOLON . subprog_decl
    (13) subprog_decl -> . proc_decl
    (14) subprog_decl -> . func_decl
    (15) proc_decl -> . PROCEDURE proc_name LPAREN RPAREN SEMICOLON inblock
    (16) proc_decl -> . PROCEDURE proc_name LPAREN proc_decl_act1 id_list RPAREN SEMICOLON inblock
    (22) func_decl -> . FUNCTION func_name LPAREN RPAREN SEMICOLON func_inblock
    (23) func_decl -> . FUNCTION func_name LPAREN func_decl_act1 id_list RPAREN SEMICOLON func_inblock

    IDENT           reduce using rule 9 (subprog_decl_part -> subprog_decl_list SEMICOLON .)
    IF              reduce using rule 9 (subprog_decl_part -> subprog_decl_list SEMICOLON .)
    WHILE           reduce using rule 9 (subprog_decl_part -> subprog_decl_list SEMICOLON .)
    FOR             reduce using rule 9 (subprog_decl_part -> subprog_decl_list SEMICOLON .)
    BEGIN           reduce using rule 9 (subprog_decl_part -> subprog_decl_list SEMICOLON .)
    READ            reduce using rule 9 (subprog_decl_part -> subprog_decl_list SEMICOLON .)
    WRITE           reduce using rule 9 (subprog_decl_part -> subprog_decl_list SEMICOLON .)
    PERIOD          reduce using rule 9 (subprog_decl_part -> subprog_decl_list SEMICOLON .)
    PROCEDURE       shift and go to state 16
    FUNCTION        shift and go to state 17

    subprog_decl                   shift and go to state 50
    proc_decl                      shift and go to state 14
    func_decl                      shift and go to state 15

state 23

    (15) proc_decl -> PROCEDURE proc_name . LPAREN RPAREN SEMICOLON inblock
    (16) proc_decl -> PROCEDURE proc_name . LPAREN proc_decl_act1 id_list RPAREN SEMICOLON inblock

    LPAREN          shift and go to state 51


state 24

    (18) proc_name -> IDENT .

    LPAREN          reduce using rule 18 (proc_name -> IDENT .)


state 25

    (22) func_decl -> FUNCTION func_name . LPAREN RPAREN SEMICOLON func_inblock
    (23) func_decl -> FUNCTION func_name . LPAREN func_decl_act1 id_list RPAREN SEMICOLON func_inblock

    LPAREN          shift and go to state 52


state 26

    (25) func_name -> IDENT .

    LPAREN          reduce using rule 25 (func_name -> IDENT .)


state 27

    (6) var_decl_list -> var_decl_list SEMICOLON var_decl .

    SEMICOLON       reduce using rule 6 (var_decl_list -> var_decl_list SEMICOLON var_decl .)


state 28

    (91) id_list -> id_list COMMA . IDENT
    (92) id_list -> id_list COMMA . IDENT LBRACKET NUMBER INTERVAL NUMBER RBRACKET

    IDENT           shift and go to state 53


state 29

    (93) id_list -> IDENT LBRACKET . NUMBER INTERVAL NUMBER RBRACKET COMMA id_list id_list_act1

    NUMBER          shift and go to state 54


state 30

    (2) outblock -> var_decl_part subprog_decl_part outblock_act statement .

    PERIOD          reduce using rule 2 (outblock -> var_decl_part subprog_decl_part outblock_act statement .)


state 31

    (31) statement -> assignment_statement .

    PERIOD          reduce using rule 31 (statement -> assignment_statement .)
    END             reduce using rule 31 (statement -> assignment_statement .)
    SEMICOLON       reduce using rule 31 (statement -> assignment_statement .)
    ELSE            reduce using rule 31 (statement -> assignment_statement .)


state 32

    (32) statement -> if_statement .

    PERIOD          reduce using rule 32 (statement -> if_statement .)
    END             reduce using rule 32 (statement -> if_statement .)
    SEMICOLON       reduce using rule 32 (statement -> if_statement .)
    ELSE            reduce using rule 32 (statement -> if_statement .)


state 33

    (33) statement -> while_statement .

    PERIOD          reduce using rule 33 (statement -> while_statement .)
    END             reduce using rule 33 (statement -> while_statement .)
    SEMICOLON       reduce using rule 33 (statement -> while_statement .)
    ELSE            reduce using rule 33 (statement -> while_statement .)


state 34

    (34) statement -> for_statement .

    PERIOD          reduce using rule 34 (statement -> for_statement .)
    END             reduce using rule 34 (statement -> for_statement .)
    SEMICOLON       reduce using rule 34 (statement -> for_statement .)
    ELSE            reduce using rule 34 (statement -> for_statement .)


state 35

    (35) statement -> proc_call_statement .

    PERIOD          reduce using rule 35 (statement -> proc_call_statement .)
    END             reduce using rule 35 (statement -> proc_call_statement .)
    SEMICOLON       reduce using rule 35 (statement -> proc_call_statement .)
    ELSE            reduce using rule 35 (statement -> proc_call_statement .)


state 36

    (36) statement -> null_statement .

    PERIOD          reduce using rule 36 (statement -> null_statement .)
    END             reduce using rule 36 (statement -> null_statement .)
    SEMICOLON       reduce using rule 36 (statement -> null_statement .)
    ELSE            reduce using rule 36 (statement -> null_statement .)


state 37

    (37) statement -> block_statement .

    PERIOD          reduce using rule 37 (statement -> block_statement .)
    END             reduce using rule 37 (statement -> block_statement .)
    SEMICOLON       reduce using rule 37 (statement -> block_statement .)
    ELSE            reduce using rule 37 (statement -> block_statement .)


state 38

    (38) statement -> read_statement .

    PERIOD          reduce using rule 38 (statement -> read_statement .)
    END             reduce using rule 38 (statement -> read_statement .)
    SEMICOLON       reduce using rule 38 (statement -> read_statement .)
    ELSE            reduce using rule 38 (statement -> read_statement .)


state 39

    (39) statement -> write_statement .

    PERIOD          reduce using rule 39 (statement -> write_statement .)
    END             reduce using rule 39 (statement -> write_statement .)
    SEMICOLON       reduce using rule 39 (statement -> write_statement .)
    ELSE            reduce using rule 39 (statement -> write_statement .)


state 40

    (40) statement -> func_call_statement .

    PERIOD          reduce using rule 40 (statement -> func_call_statement .)
    END             reduce using rule 40 (statement -> func_call_statement .)
    SEMICOLON       reduce using rule 40 (statement -> func_call_statement .)
    ELSE            reduce using rule 40 (statement -> func_call_statement .)


state 41

    (41) assignment_statement -> IDENT . ASSIGN expression
    (42) assignment_statement -> IDENT . LBRACKET expression RBRACKET ASSIGN expression
    (61) proc_call_name -> IDENT .
    (62) func_call_name -> IDENT .

  ! reduce/reduce conflict for LPAREN resolved using rule 61 (proc_call_name -> IDENT .)
    ASSIGN          shift and go to state 55
    LBRACKET        shift and go to state 56
    LPAREN          reduce using rule 61 (proc_call_name -> IDENT .)

  ! LPAREN          [ reduce using rule 62 (func_call_name -> IDENT .) ]


state 42

    (43) if_statement -> IF . condition if_act1 THEN statement else_statement
    (68) condition -> . expression EQ expression
    (69) condition -> . expression NEQ expression
    (70) condition -> . expression LT expression
    (71) condition -> . expression LE expression
    (72) condition -> . expression GT expression
    (73) condition -> . expression GE expression
    (74) expression -> . term
    (75) expression -> . MINUS term
    (76) expression -> . expression PLUS term
    (77) expression -> . expression MINUS term
    (78) expression -> . func_call_statement
    (79) term -> . factor
    (80) term -> . term MULT factor
    (81) term -> . term DIV factor
    (82) term -> . func_call_statement
    (56) func_call_statement -> . func_call_name LPAREN RPAREN
    (57) func_call_statement -> . func_call_name LPAREN func_call_statement_act1 arg_list RPAREN
    (83) factor -> . var_name
    (84) factor -> . number
    (85) factor -> . LPAREN expression RPAREN
    (86) factor -> . func_call_statement
    (62) func_call_name -> . IDENT
    (87) var_name -> . IDENT
    (88) var_name -> . IDENT LBRACKET expression RBRACKET
    (89) number -> . NUMBER

    MINUS           shift and go to state 60
    LPAREN          shift and go to state 63
    IDENT           shift and go to state 66
    NUMBER          shift and go to state 67

    condition                      shift and go to state 57
    expression                     shift and go to state 58
    term                           shift and go to state 59
    func_call_statement            shift and go to state 61
    factor                         shift and go to state 62
    func_call_name                 shift and go to state 49
    var_name                       shift and go to state 64
    number                         shift and go to state 65

state 43

    (48) while_statement -> WHILE . while_act1 condition while_act2 DO statement
    (49) while_act1 -> .

    MINUS           reduce using rule 49 (while_act1 -> .)
    LPAREN          reduce using rule 49 (while_act1 -> .)
    IDENT           reduce using rule 49 (while_act1 -> .)
    NUMBER          reduce using rule 49 (while_act1 -> .)

    while_act1                     shift and go to state 68

state 44

    (51) for_statement -> FOR . IDENT ASSIGN expression TO expression for_act1 DO statement

    IDENT           shift and go to state 69


state 45

    (53) proc_call_statement -> proc_call_name . LPAREN RPAREN
    (54) proc_call_statement -> proc_call_name . LPAREN proc_call_statement_act1 arg_list RPAREN

    LPAREN          shift and go to state 70


state 46

    (63) block_statement -> BEGIN . statement_list END
    (29) statement_list -> . statement_list SEMICOLON statement
    (30) statement_list -> . statement
    (31) statement -> . assignment_statement
    (32) statement -> . if_statement
    (33) statement -> . while_statement
    (34) statement -> . for_statement
    (35) statement -> . proc_call_statement
    (36) statement -> . null_statement
    (37) statement -> . block_statement
    (38) statement -> . read_statement
    (39) statement -> . write_statement
    (40) statement -> . func_call_statement
    (41) assignment_statement -> . IDENT ASSIGN expression
    (42) assignment_statement -> . IDENT LBRACKET expression RBRACKET ASSIGN expression
    (43) if_statement -> . IF condition if_act1 THEN statement else_statement
    (48) while_statement -> . WHILE while_act1 condition while_act2 DO statement
    (51) for_statement -> . FOR IDENT ASSIGN expression TO expression for_act1 DO statement
    (53) proc_call_statement -> . proc_call_name LPAREN RPAREN
    (54) proc_call_statement -> . proc_call_name LPAREN proc_call_statement_act1 arg_list RPAREN
    (67) null_statement -> .
    (63) block_statement -> . BEGIN statement_list END
    (64) read_statement -> . READ LPAREN IDENT RPAREN
    (65) read_statement -> . READ LPAREN IDENT LBRACKET expression RBRACKET RPAREN
    (66) write_statement -> . WRITE LPAREN expression RPAREN
    (56) func_call_statement -> . func_call_name LPAREN RPAREN
    (57) func_call_statement -> . func_call_name LPAREN func_call_statement_act1 arg_list RPAREN
    (61) proc_call_name -> . IDENT
    (62) func_call_name -> . IDENT

    IDENT           shift and go to state 41
    IF              shift and go to state 42
    WHILE           shift and go to state 43
    FOR             shift and go to state 44
    END             reduce using rule 67 (null_statement -> .)
    SEMICOLON       reduce using rule 67 (null_statement -> .)
    BEGIN           shift and go to state 46
    READ            shift and go to state 47
    WRITE           shift and go to state 48

    statement_list                 shift and go to state 71
    statement                      shift and go to state 72
    assignment_statement           shift and go to state 31
    if_statement                   shift and go to state 32
    while_statement                shift and go to state 33
    for_statement                  shift and go to state 34
    proc_call_statement            shift and go to state 35
    null_statement                 shift and go to state 36
    block_statement                shift and go to state 37
    read_statement                 shift and go to state 38
    write_statement                shift and go to state 39
    func_call_statement            shift and go to state 40
    proc_call_name                 shift and go to state 45
    func_call_name                 shift and go to state 49

state 47

    (64) read_statement -> READ . LPAREN IDENT RPAREN
    (65) read_statement -> READ . LPAREN IDENT LBRACKET expression RBRACKET RPAREN

    LPAREN          shift and go to state 73


state 48

    (66) write_statement -> WRITE . LPAREN expression RPAREN

    LPAREN          shift and go to state 74


state 49

    (56) func_call_statement -> func_call_name . LPAREN RPAREN
    (57) func_call_statement -> func_call_name . LPAREN func_call_statement_act1 arg_list RPAREN

    LPAREN          shift and go to state 75


state 50

    (11) subprog_decl_list -> subprog_decl_list SEMICOLON subprog_decl .

    SEMICOLON       reduce using rule 11 (subprog_decl_list -> subprog_decl_list SEMICOLON subprog_decl .)


state 51

    (15) proc_decl -> PROCEDURE proc_name LPAREN . RPAREN SEMICOLON inblock
    (16) proc_decl -> PROCEDURE proc_name LPAREN . proc_decl_act1 id_list RPAREN SEMICOLON inblock
    (17) proc_decl_act1 -> .

    RPAREN          shift and go to state 76
    IDENT           reduce using rule 17 (proc_decl_act1 -> .)

    proc_decl_act1                 shift and go to state 77

state 52

    (22) func_decl -> FUNCTION func_name LPAREN . RPAREN SEMICOLON func_inblock
    (23) func_decl -> FUNCTION func_name LPAREN . func_decl_act1 id_list RPAREN SEMICOLON func_inblock
    (24) func_decl_act1 -> .

    RPAREN          shift and go to state 78
    IDENT           reduce using rule 24 (func_decl_act1 -> .)

    func_decl_act1                 shift and go to state 79

state 53

    (91) id_list -> id_list COMMA IDENT .
    (92) id_list -> id_list COMMA IDENT . LBRACKET NUMBER INTERVAL NUMBER RBRACKET

    COMMA           reduce using rule 91 (id_list -> id_list COMMA IDENT .)
    SEMICOLON       reduce using rule 91 (id_list -> id_list COMMA IDENT .)
    RPAREN          reduce using rule 91 (id_list -> id_list COMMA IDENT .)
    LBRACKET        shift and go to state 80


state 54

    (93) id_list -> IDENT LBRACKET NUMBER . INTERVAL NUMBER RBRACKET COMMA id_list id_list_act1

    INTERVAL        shift and go to state 81


state 55

    (41) assignment_statement -> IDENT ASSIGN . expression
    (74) expression -> . term
    (75) expression -> . MINUS term
    (76) expression -> . expression PLUS term
    (77) expression -> . expression MINUS term
    (78) expression -> . func_call_statement
    (79) term -> . factor
    (80) term -> . term MULT factor
    (81) term -> . term DIV factor
    (82) term -> . func_call_statement
    (56) func_call_statement -> . func_call_name LPAREN RPAREN
    (57) func_call_statement -> . func_call_name LPAREN func_call_statement_act1 arg_list RPAREN
    (83) factor -> . var_name
    (84) factor -> . number
    (85) factor -> . LPAREN expression RPAREN
    (86) factor -> . func_call_statement
    (62) func_call_name -> . IDENT
    (87) var_name -> . IDENT
    (88) var_name -> . IDENT LBRACKET expression RBRACKET
    (89) number -> . NUMBER

    MINUS           shift and go to state 60
    LPAREN          shift and go to state 63
    IDENT           shift and go to state 66
    NUMBER          shift and go to state 67

    expression                     shift and go to state 82
    term                           shift and go to state 59
    func_call_statement            shift and go to state 61
    factor                         shift and go to state 62
    func_call_name                 shift and go to state 49
    var_name                       shift and go to state 64
    number                         shift and go to state 65

state 56

    (42) assignment_statement -> IDENT LBRACKET . expression RBRACKET ASSIGN expression
    (74) expression -> . term
    (75) expression -> . MINUS term
    (76) expression -> . expression PLUS term
    (77) expression -> . expression MINUS term
    (78) expression -> . func_call_statement
    (79) term -> . factor
    (80) term -> . term MULT factor
    (81) term -> . term DIV factor
    (82) term -> . func_call_statement
    (56) func_call_statement -> . func_call_name LPAREN RPAREN
    (57) func_call_statement -> . func_call_name LPAREN func_call_statement_act1 arg_list RPAREN
    (83) factor -> . var_name
    (84) factor -> . number
    (85) factor -> . LPAREN expression RPAREN
    (86) factor -> . func_call_statement
    (62) func_call_name -> . IDENT
    (87) var_name -> . IDENT
    (88) var_name -> . IDENT LBRACKET expression RBRACKET
    (89) number -> . NUMBER

    MINUS           shift and go to state 60
    LPAREN          shift and go to state 63
    IDENT           shift and go to state 66
    NUMBER          shift and go to state 67

    expression                     shift and go to state 83
    term                           shift and go to state 59
    func_call_statement            shift and go to state 61
    factor                         shift and go to state 62
    func_call_name                 shift and go to state 49
    var_name                       shift and go to state 64
    number                         shift and go to state 65

state 57

    (43) if_statement -> IF condition . if_act1 THEN statement else_statement
    (44) if_act1 -> .

    THEN            reduce using rule 44 (if_act1 -> .)

    if_act1                        shift and go to state 84

state 58

    (68) condition -> expression . EQ expression
    (69) condition -> expression . NEQ expression
    (70) condition -> expression . LT expression
    (71) condition -> expression . LE expression
    (72) condition -> expression . GT expression
    (73) condition -> expression . GE expression
    (76) expression -> expression . PLUS term
    (77) expression -> expression . MINUS term

    EQ              shift and go to state 85
    NEQ             shift and go to state 86
    LT              shift and go to state 87
    LE              shift and go to state 88
    GT              shift and go to state 89
    GE              shift and go to state 90
    PLUS            shift and go to state 91
    MINUS           shift and go to state 92


state 59

    (74) expression -> term .
    (80) term -> term . MULT factor
    (81) term -> term . DIV factor

    EQ              reduce using rule 74 (expression -> term .)
    NEQ             reduce using rule 74 (expression -> term .)
    LT              reduce using rule 74 (expression -> term .)
    LE              reduce using rule 74 (expression -> term .)
    GT              reduce using rule 74 (expression -> term .)
    GE              reduce using rule 74 (expression -> term .)
    PLUS            reduce using rule 74 (expression -> term .)
    MINUS           reduce using rule 74 (expression -> term .)
    PERIOD          reduce using rule 74 (expression -> term .)
    END             reduce using rule 74 (expression -> term .)
    SEMICOLON       reduce using rule 74 (expression -> term .)
    ELSE            reduce using rule 74 (expression -> term .)
    RBRACKET        reduce using rule 74 (expression -> term .)
    RPAREN          reduce using rule 74 (expression -> term .)
    THEN            reduce using rule 74 (expression -> term .)
    DO              reduce using rule 74 (expression -> term .)
    TO              reduce using rule 74 (expression -> term .)
    COMMA           reduce using rule 74 (expression -> term .)
    MULT            shift and go to state 93
    DIV             shift and go to state 94


state 60

    (75) expression -> MINUS . term
    (79) term -> . factor
    (80) term -> . term MULT factor
    (81) term -> . term DIV factor
    (82) term -> . func_call_statement
    (83) factor -> . var_name
    (84) factor -> . number
    (85) factor -> . LPAREN expression RPAREN
    (86) factor -> . func_call_statement
    (56) func_call_statement -> . func_call_name LPAREN RPAREN
    (57) func_call_statement -> . func_call_name LPAREN func_call_statement_act1 arg_list RPAREN
    (87) var_name -> . IDENT
    (88) var_name -> . IDENT LBRACKET expression RBRACKET
    (89) number -> . NUMBER
    (62) func_call_name -> . IDENT

    LPAREN          shift and go to state 63
    IDENT           shift and go to state 97
    NUMBER          shift and go to state 67

    term                           shift and go to state 95
    factor                         shift and go to state 62
    func_call_statement            shift and go to state 96
    var_name                       shift and go to state 64
    number                         shift and go to state 65
    func_call_name                 shift and go to state 49

state 61

    (78) expression -> func_call_statement .
    (82) term -> func_call_statement .
    (86) factor -> func_call_statement .

  ! reduce/reduce conflict for EQ resolved using rule 78 (expression -> func_call_statement .)
  ! reduce/reduce conflict for NEQ resolved using rule 78 (expression -> func_call_statement .)
  ! reduce/reduce conflict for LT resolved using rule 78 (expression -> func_call_statement .)
  ! reduce/reduce conflict for LE resolved using rule 78 (expression -> func_call_statement .)
  ! reduce/reduce conflict for GT resolved using rule 78 (expression -> func_call_statement .)
  ! reduce/reduce conflict for GE resolved using rule 78 (expression -> func_call_statement .)
  ! reduce/reduce conflict for PLUS resolved using rule 78 (expression -> func_call_statement .)
  ! reduce/reduce conflict for MINUS resolved using rule 78 (expression -> func_call_statement .)
  ! reduce/reduce conflict for PERIOD resolved using rule 78 (expression -> func_call_statement .)
  ! reduce/reduce conflict for END resolved using rule 78 (expression -> func_call_statement .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 78 (expression -> func_call_statement .)
  ! reduce/reduce conflict for ELSE resolved using rule 78 (expression -> func_call_statement .)
  ! reduce/reduce conflict for RBRACKET resolved using rule 78 (expression -> func_call_statement .)
  ! reduce/reduce conflict for RPAREN resolved using rule 78 (expression -> func_call_statement .)
  ! reduce/reduce conflict for THEN resolved using rule 78 (expression -> func_call_statement .)
  ! reduce/reduce conflict for DO resolved using rule 78 (expression -> func_call_statement .)
  ! reduce/reduce conflict for TO resolved using rule 78 (expression -> func_call_statement .)
  ! reduce/reduce conflict for COMMA resolved using rule 78 (expression -> func_call_statement .)
  ! reduce/reduce conflict for MULT resolved using rule 82 (term -> func_call_statement .)
  ! reduce/reduce conflict for DIV resolved using rule 82 (term -> func_call_statement .)
  ! reduce/reduce conflict for EQ resolved using rule 78 (expression -> func_call_statement .)
  ! reduce/reduce conflict for NEQ resolved using rule 78 (expression -> func_call_statement .)
  ! reduce/reduce conflict for LT resolved using rule 78 (expression -> func_call_statement .)
  ! reduce/reduce conflict for LE resolved using rule 78 (expression -> func_call_statement .)
  ! reduce/reduce conflict for GT resolved using rule 78 (expression -> func_call_statement .)
  ! reduce/reduce conflict for GE resolved using rule 78 (expression -> func_call_statement .)
  ! reduce/reduce conflict for PLUS resolved using rule 78 (expression -> func_call_statement .)
  ! reduce/reduce conflict for MINUS resolved using rule 78 (expression -> func_call_statement .)
  ! reduce/reduce conflict for PERIOD resolved using rule 78 (expression -> func_call_statement .)
  ! reduce/reduce conflict for END resolved using rule 78 (expression -> func_call_statement .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 78 (expression -> func_call_statement .)
  ! reduce/reduce conflict for ELSE resolved using rule 78 (expression -> func_call_statement .)
  ! reduce/reduce conflict for RBRACKET resolved using rule 78 (expression -> func_call_statement .)
  ! reduce/reduce conflict for RPAREN resolved using rule 78 (expression -> func_call_statement .)
  ! reduce/reduce conflict for THEN resolved using rule 78 (expression -> func_call_statement .)
  ! reduce/reduce conflict for DO resolved using rule 78 (expression -> func_call_statement .)
  ! reduce/reduce conflict for TO resolved using rule 78 (expression -> func_call_statement .)
  ! reduce/reduce conflict for COMMA resolved using rule 78 (expression -> func_call_statement .)
    EQ              reduce using rule 78 (expression -> func_call_statement .)
    NEQ             reduce using rule 78 (expression -> func_call_statement .)
    LT              reduce using rule 78 (expression -> func_call_statement .)
    LE              reduce using rule 78 (expression -> func_call_statement .)
    GT              reduce using rule 78 (expression -> func_call_statement .)
    GE              reduce using rule 78 (expression -> func_call_statement .)
    PLUS            reduce using rule 78 (expression -> func_call_statement .)
    MINUS           reduce using rule 78 (expression -> func_call_statement .)
    PERIOD          reduce using rule 78 (expression -> func_call_statement .)
    END             reduce using rule 78 (expression -> func_call_statement .)
    SEMICOLON       reduce using rule 78 (expression -> func_call_statement .)
    ELSE            reduce using rule 78 (expression -> func_call_statement .)
    RBRACKET        reduce using rule 78 (expression -> func_call_statement .)
    RPAREN          reduce using rule 78 (expression -> func_call_statement .)
    THEN            reduce using rule 78 (expression -> func_call_statement .)
    DO              reduce using rule 78 (expression -> func_call_statement .)
    TO              reduce using rule 78 (expression -> func_call_statement .)
    COMMA           reduce using rule 78 (expression -> func_call_statement .)
    MULT            reduce using rule 82 (term -> func_call_statement .)
    DIV             reduce using rule 82 (term -> func_call_statement .)

  ! EQ              [ reduce using rule 82 (term -> func_call_statement .) ]
  ! NEQ             [ reduce using rule 82 (term -> func_call_statement .) ]
  ! LT              [ reduce using rule 82 (term -> func_call_statement .) ]
  ! LE              [ reduce using rule 82 (term -> func_call_statement .) ]
  ! GT              [ reduce using rule 82 (term -> func_call_statement .) ]
  ! GE              [ reduce using rule 82 (term -> func_call_statement .) ]
  ! PLUS            [ reduce using rule 82 (term -> func_call_statement .) ]
  ! MINUS           [ reduce using rule 82 (term -> func_call_statement .) ]
  ! PERIOD          [ reduce using rule 82 (term -> func_call_statement .) ]
  ! END             [ reduce using rule 82 (term -> func_call_statement .) ]
  ! SEMICOLON       [ reduce using rule 82 (term -> func_call_statement .) ]
  ! ELSE            [ reduce using rule 82 (term -> func_call_statement .) ]
  ! RBRACKET        [ reduce using rule 82 (term -> func_call_statement .) ]
  ! RPAREN          [ reduce using rule 82 (term -> func_call_statement .) ]
  ! THEN            [ reduce using rule 82 (term -> func_call_statement .) ]
  ! DO              [ reduce using rule 82 (term -> func_call_statement .) ]
  ! TO              [ reduce using rule 82 (term -> func_call_statement .) ]
  ! COMMA           [ reduce using rule 82 (term -> func_call_statement .) ]
  ! MULT            [ reduce using rule 86 (factor -> func_call_statement .) ]
  ! DIV             [ reduce using rule 86 (factor -> func_call_statement .) ]
  ! EQ              [ reduce using rule 86 (factor -> func_call_statement .) ]
  ! NEQ             [ reduce using rule 86 (factor -> func_call_statement .) ]
  ! LT              [ reduce using rule 86 (factor -> func_call_statement .) ]
  ! LE              [ reduce using rule 86 (factor -> func_call_statement .) ]
  ! GT              [ reduce using rule 86 (factor -> func_call_statement .) ]
  ! GE              [ reduce using rule 86 (factor -> func_call_statement .) ]
  ! PLUS            [ reduce using rule 86 (factor -> func_call_statement .) ]
  ! MINUS           [ reduce using rule 86 (factor -> func_call_statement .) ]
  ! PERIOD          [ reduce using rule 86 (factor -> func_call_statement .) ]
  ! END             [ reduce using rule 86 (factor -> func_call_statement .) ]
  ! SEMICOLON       [ reduce using rule 86 (factor -> func_call_statement .) ]
  ! ELSE            [ reduce using rule 86 (factor -> func_call_statement .) ]
  ! RBRACKET        [ reduce using rule 86 (factor -> func_call_statement .) ]
  ! RPAREN          [ reduce using rule 86 (factor -> func_call_statement .) ]
  ! THEN            [ reduce using rule 86 (factor -> func_call_statement .) ]
  ! DO              [ reduce using rule 86 (factor -> func_call_statement .) ]
  ! TO              [ reduce using rule 86 (factor -> func_call_statement .) ]
  ! COMMA           [ reduce using rule 86 (factor -> func_call_statement .) ]


state 62

    (79) term -> factor .

    MULT            reduce using rule 79 (term -> factor .)
    DIV             reduce using rule 79 (term -> factor .)
    EQ              reduce using rule 79 (term -> factor .)
    NEQ             reduce using rule 79 (term -> factor .)
    LT              reduce using rule 79 (term -> factor .)
    LE              reduce using rule 79 (term -> factor .)
    GT              reduce using rule 79 (term -> factor .)
    GE              reduce using rule 79 (term -> factor .)
    PLUS            reduce using rule 79 (term -> factor .)
    MINUS           reduce using rule 79 (term -> factor .)
    PERIOD          reduce using rule 79 (term -> factor .)
    END             reduce using rule 79 (term -> factor .)
    SEMICOLON       reduce using rule 79 (term -> factor .)
    ELSE            reduce using rule 79 (term -> factor .)
    RBRACKET        reduce using rule 79 (term -> factor .)
    RPAREN          reduce using rule 79 (term -> factor .)
    THEN            reduce using rule 79 (term -> factor .)
    DO              reduce using rule 79 (term -> factor .)
    TO              reduce using rule 79 (term -> factor .)
    COMMA           reduce using rule 79 (term -> factor .)


state 63

    (85) factor -> LPAREN . expression RPAREN
    (74) expression -> . term
    (75) expression -> . MINUS term
    (76) expression -> . expression PLUS term
    (77) expression -> . expression MINUS term
    (78) expression -> . func_call_statement
    (79) term -> . factor
    (80) term -> . term MULT factor
    (81) term -> . term DIV factor
    (82) term -> . func_call_statement
    (56) func_call_statement -> . func_call_name LPAREN RPAREN
    (57) func_call_statement -> . func_call_name LPAREN func_call_statement_act1 arg_list RPAREN
    (83) factor -> . var_name
    (84) factor -> . number
    (85) factor -> . LPAREN expression RPAREN
    (86) factor -> . func_call_statement
    (62) func_call_name -> . IDENT
    (87) var_name -> . IDENT
    (88) var_name -> . IDENT LBRACKET expression RBRACKET
    (89) number -> . NUMBER

    MINUS           shift and go to state 60
    LPAREN          shift and go to state 63
    IDENT           shift and go to state 66
    NUMBER          shift and go to state 67

    expression                     shift and go to state 98
    term                           shift and go to state 59
    func_call_statement            shift and go to state 61
    factor                         shift and go to state 62
    func_call_name                 shift and go to state 49
    var_name                       shift and go to state 64
    number                         shift and go to state 65

state 64

    (83) factor -> var_name .

    MULT            reduce using rule 83 (factor -> var_name .)
    DIV             reduce using rule 83 (factor -> var_name .)
    EQ              reduce using rule 83 (factor -> var_name .)
    NEQ             reduce using rule 83 (factor -> var_name .)
    LT              reduce using rule 83 (factor -> var_name .)
    LE              reduce using rule 83 (factor -> var_name .)
    GT              reduce using rule 83 (factor -> var_name .)
    GE              reduce using rule 83 (factor -> var_name .)
    PLUS            reduce using rule 83 (factor -> var_name .)
    MINUS           reduce using rule 83 (factor -> var_name .)
    PERIOD          reduce using rule 83 (factor -> var_name .)
    END             reduce using rule 83 (factor -> var_name .)
    SEMICOLON       reduce using rule 83 (factor -> var_name .)
    ELSE            reduce using rule 83 (factor -> var_name .)
    RBRACKET        reduce using rule 83 (factor -> var_name .)
    RPAREN          reduce using rule 83 (factor -> var_name .)
    THEN            reduce using rule 83 (factor -> var_name .)
    DO              reduce using rule 83 (factor -> var_name .)
    TO              reduce using rule 83 (factor -> var_name .)
    COMMA           reduce using rule 83 (factor -> var_name .)


state 65

    (84) factor -> number .

    MULT            reduce using rule 84 (factor -> number .)
    DIV             reduce using rule 84 (factor -> number .)
    EQ              reduce using rule 84 (factor -> number .)
    NEQ             reduce using rule 84 (factor -> number .)
    LT              reduce using rule 84 (factor -> number .)
    LE              reduce using rule 84 (factor -> number .)
    GT              reduce using rule 84 (factor -> number .)
    GE              reduce using rule 84 (factor -> number .)
    PLUS            reduce using rule 84 (factor -> number .)
    MINUS           reduce using rule 84 (factor -> number .)
    PERIOD          reduce using rule 84 (factor -> number .)
    END             reduce using rule 84 (factor -> number .)
    SEMICOLON       reduce using rule 84 (factor -> number .)
    ELSE            reduce using rule 84 (factor -> number .)
    RBRACKET        reduce using rule 84 (factor -> number .)
    RPAREN          reduce using rule 84 (factor -> number .)
    THEN            reduce using rule 84 (factor -> number .)
    DO              reduce using rule 84 (factor -> number .)
    TO              reduce using rule 84 (factor -> number .)
    COMMA           reduce using rule 84 (factor -> number .)


state 66

    (62) func_call_name -> IDENT .
    (87) var_name -> IDENT .
    (88) var_name -> IDENT . LBRACKET expression RBRACKET

    LPAREN          reduce using rule 62 (func_call_name -> IDENT .)
    MULT            reduce using rule 87 (var_name -> IDENT .)
    DIV             reduce using rule 87 (var_name -> IDENT .)
    EQ              reduce using rule 87 (var_name -> IDENT .)
    NEQ             reduce using rule 87 (var_name -> IDENT .)
    LT              reduce using rule 87 (var_name -> IDENT .)
    LE              reduce using rule 87 (var_name -> IDENT .)
    GT              reduce using rule 87 (var_name -> IDENT .)
    GE              reduce using rule 87 (var_name -> IDENT .)
    PLUS            reduce using rule 87 (var_name -> IDENT .)
    MINUS           reduce using rule 87 (var_name -> IDENT .)
    PERIOD          reduce using rule 87 (var_name -> IDENT .)
    END             reduce using rule 87 (var_name -> IDENT .)
    SEMICOLON       reduce using rule 87 (var_name -> IDENT .)
    ELSE            reduce using rule 87 (var_name -> IDENT .)
    RBRACKET        reduce using rule 87 (var_name -> IDENT .)
    RPAREN          reduce using rule 87 (var_name -> IDENT .)
    THEN            reduce using rule 87 (var_name -> IDENT .)
    DO              reduce using rule 87 (var_name -> IDENT .)
    TO              reduce using rule 87 (var_name -> IDENT .)
    COMMA           reduce using rule 87 (var_name -> IDENT .)
    LBRACKET        shift and go to state 99


state 67

    (89) number -> NUMBER .

    MULT            reduce using rule 89 (number -> NUMBER .)
    DIV             reduce using rule 89 (number -> NUMBER .)
    EQ              reduce using rule 89 (number -> NUMBER .)
    NEQ             reduce using rule 89 (number -> NUMBER .)
    LT              reduce using rule 89 (number -> NUMBER .)
    LE              reduce using rule 89 (number -> NUMBER .)
    GT              reduce using rule 89 (number -> NUMBER .)
    GE              reduce using rule 89 (number -> NUMBER .)
    PLUS            reduce using rule 89 (number -> NUMBER .)
    MINUS           reduce using rule 89 (number -> NUMBER .)
    PERIOD          reduce using rule 89 (number -> NUMBER .)
    END             reduce using rule 89 (number -> NUMBER .)
    SEMICOLON       reduce using rule 89 (number -> NUMBER .)
    ELSE            reduce using rule 89 (number -> NUMBER .)
    RBRACKET        reduce using rule 89 (number -> NUMBER .)
    RPAREN          reduce using rule 89 (number -> NUMBER .)
    THEN            reduce using rule 89 (number -> NUMBER .)
    DO              reduce using rule 89 (number -> NUMBER .)
    TO              reduce using rule 89 (number -> NUMBER .)
    COMMA           reduce using rule 89 (number -> NUMBER .)


state 68

    (48) while_statement -> WHILE while_act1 . condition while_act2 DO statement
    (68) condition -> . expression EQ expression
    (69) condition -> . expression NEQ expression
    (70) condition -> . expression LT expression
    (71) condition -> . expression LE expression
    (72) condition -> . expression GT expression
    (73) condition -> . expression GE expression
    (74) expression -> . term
    (75) expression -> . MINUS term
    (76) expression -> . expression PLUS term
    (77) expression -> . expression MINUS term
    (78) expression -> . func_call_statement
    (79) term -> . factor
    (80) term -> . term MULT factor
    (81) term -> . term DIV factor
    (82) term -> . func_call_statement
    (56) func_call_statement -> . func_call_name LPAREN RPAREN
    (57) func_call_statement -> . func_call_name LPAREN func_call_statement_act1 arg_list RPAREN
    (83) factor -> . var_name
    (84) factor -> . number
    (85) factor -> . LPAREN expression RPAREN
    (86) factor -> . func_call_statement
    (62) func_call_name -> . IDENT
    (87) var_name -> . IDENT
    (88) var_name -> . IDENT LBRACKET expression RBRACKET
    (89) number -> . NUMBER

    MINUS           shift and go to state 60
    LPAREN          shift and go to state 63
    IDENT           shift and go to state 66
    NUMBER          shift and go to state 67

    condition                      shift and go to state 100
    expression                     shift and go to state 58
    term                           shift and go to state 59
    func_call_statement            shift and go to state 61
    factor                         shift and go to state 62
    func_call_name                 shift and go to state 49
    var_name                       shift and go to state 64
    number                         shift and go to state 65

state 69

    (51) for_statement -> FOR IDENT . ASSIGN expression TO expression for_act1 DO statement

    ASSIGN          shift and go to state 101


state 70

    (53) proc_call_statement -> proc_call_name LPAREN . RPAREN
    (54) proc_call_statement -> proc_call_name LPAREN . proc_call_statement_act1 arg_list RPAREN
    (55) proc_call_statement_act1 -> .

    RPAREN          shift and go to state 102
    MINUS           reduce using rule 55 (proc_call_statement_act1 -> .)
    LPAREN          reduce using rule 55 (proc_call_statement_act1 -> .)
    IDENT           reduce using rule 55 (proc_call_statement_act1 -> .)
    NUMBER          reduce using rule 55 (proc_call_statement_act1 -> .)

    proc_call_statement_act1       shift and go to state 103

state 71

    (63) block_statement -> BEGIN statement_list . END
    (29) statement_list -> statement_list . SEMICOLON statement

    END             shift and go to state 104
    SEMICOLON       shift and go to state 105


state 72

    (30) statement_list -> statement .

    END             reduce using rule 30 (statement_list -> statement .)
    SEMICOLON       reduce using rule 30 (statement_list -> statement .)


state 73

    (64) read_statement -> READ LPAREN . IDENT RPAREN
    (65) read_statement -> READ LPAREN . IDENT LBRACKET expression RBRACKET RPAREN

    IDENT           shift and go to state 106


state 74

    (66) write_statement -> WRITE LPAREN . expression RPAREN
    (74) expression -> . term
    (75) expression -> . MINUS term
    (76) expression -> . expression PLUS term
    (77) expression -> . expression MINUS term
    (78) expression -> . func_call_statement
    (79) term -> . factor
    (80) term -> . term MULT factor
    (81) term -> . term DIV factor
    (82) term -> . func_call_statement
    (56) func_call_statement -> . func_call_name LPAREN RPAREN
    (57) func_call_statement -> . func_call_name LPAREN func_call_statement_act1 arg_list RPAREN
    (83) factor -> . var_name
    (84) factor -> . number
    (85) factor -> . LPAREN expression RPAREN
    (86) factor -> . func_call_statement
    (62) func_call_name -> . IDENT
    (87) var_name -> . IDENT
    (88) var_name -> . IDENT LBRACKET expression RBRACKET
    (89) number -> . NUMBER

    MINUS           shift and go to state 60
    LPAREN          shift and go to state 63
    IDENT           shift and go to state 66
    NUMBER          shift and go to state 67

    expression                     shift and go to state 107
    term                           shift and go to state 59
    func_call_statement            shift and go to state 61
    factor                         shift and go to state 62
    func_call_name                 shift and go to state 49
    var_name                       shift and go to state 64
    number                         shift and go to state 65

state 75

    (56) func_call_statement -> func_call_name LPAREN . RPAREN
    (57) func_call_statement -> func_call_name LPAREN . func_call_statement_act1 arg_list RPAREN
    (58) func_call_statement_act1 -> .

    RPAREN          shift and go to state 108
    MINUS           reduce using rule 58 (func_call_statement_act1 -> .)
    LPAREN          reduce using rule 58 (func_call_statement_act1 -> .)
    IDENT           reduce using rule 58 (func_call_statement_act1 -> .)
    NUMBER          reduce using rule 58 (func_call_statement_act1 -> .)

    func_call_statement_act1       shift and go to state 109

state 76

    (15) proc_decl -> PROCEDURE proc_name LPAREN RPAREN . SEMICOLON inblock

    SEMICOLON       shift and go to state 110


state 77

    (16) proc_decl -> PROCEDURE proc_name LPAREN proc_decl_act1 . id_list RPAREN SEMICOLON inblock
    (90) id_list -> . IDENT
    (91) id_list -> . id_list COMMA IDENT
    (92) id_list -> . id_list COMMA IDENT LBRACKET NUMBER INTERVAL NUMBER RBRACKET
    (93) id_list -> . IDENT LBRACKET NUMBER INTERVAL NUMBER RBRACKET COMMA id_list id_list_act1

    IDENT           shift and go to state 20

    id_list                        shift and go to state 111

state 78

    (22) func_decl -> FUNCTION func_name LPAREN RPAREN . SEMICOLON func_inblock

    SEMICOLON       shift and go to state 112


state 79

    (23) func_decl -> FUNCTION func_name LPAREN func_decl_act1 . id_list RPAREN SEMICOLON func_inblock
    (90) id_list -> . IDENT
    (91) id_list -> . id_list COMMA IDENT
    (92) id_list -> . id_list COMMA IDENT LBRACKET NUMBER INTERVAL NUMBER RBRACKET
    (93) id_list -> . IDENT LBRACKET NUMBER INTERVAL NUMBER RBRACKET COMMA id_list id_list_act1

    IDENT           shift and go to state 20

    id_list                        shift and go to state 113

state 80

    (92) id_list -> id_list COMMA IDENT LBRACKET . NUMBER INTERVAL NUMBER RBRACKET

    NUMBER          shift and go to state 114


state 81

    (93) id_list -> IDENT LBRACKET NUMBER INTERVAL . NUMBER RBRACKET COMMA id_list id_list_act1

    NUMBER          shift and go to state 115


state 82

    (41) assignment_statement -> IDENT ASSIGN expression .
    (76) expression -> expression . PLUS term
    (77) expression -> expression . MINUS term

    PERIOD          reduce using rule 41 (assignment_statement -> IDENT ASSIGN expression .)
    END             reduce using rule 41 (assignment_statement -> IDENT ASSIGN expression .)
    SEMICOLON       reduce using rule 41 (assignment_statement -> IDENT ASSIGN expression .)
    ELSE            reduce using rule 41 (assignment_statement -> IDENT ASSIGN expression .)
    PLUS            shift and go to state 91
    MINUS           shift and go to state 92


state 83

    (42) assignment_statement -> IDENT LBRACKET expression . RBRACKET ASSIGN expression
    (76) expression -> expression . PLUS term
    (77) expression -> expression . MINUS term

    RBRACKET        shift and go to state 116
    PLUS            shift and go to state 91
    MINUS           shift and go to state 92


state 84

    (43) if_statement -> IF condition if_act1 . THEN statement else_statement

    THEN            shift and go to state 117


state 85

    (68) condition -> expression EQ . expression
    (74) expression -> . term
    (75) expression -> . MINUS term
    (76) expression -> . expression PLUS term
    (77) expression -> . expression MINUS term
    (78) expression -> . func_call_statement
    (79) term -> . factor
    (80) term -> . term MULT factor
    (81) term -> . term DIV factor
    (82) term -> . func_call_statement
    (56) func_call_statement -> . func_call_name LPAREN RPAREN
    (57) func_call_statement -> . func_call_name LPAREN func_call_statement_act1 arg_list RPAREN
    (83) factor -> . var_name
    (84) factor -> . number
    (85) factor -> . LPAREN expression RPAREN
    (86) factor -> . func_call_statement
    (62) func_call_name -> . IDENT
    (87) var_name -> . IDENT
    (88) var_name -> . IDENT LBRACKET expression RBRACKET
    (89) number -> . NUMBER

    MINUS           shift and go to state 60
    LPAREN          shift and go to state 63
    IDENT           shift and go to state 66
    NUMBER          shift and go to state 67

    expression                     shift and go to state 118
    term                           shift and go to state 59
    func_call_statement            shift and go to state 61
    factor                         shift and go to state 62
    func_call_name                 shift and go to state 49
    var_name                       shift and go to state 64
    number                         shift and go to state 65

state 86

    (69) condition -> expression NEQ . expression
    (74) expression -> . term
    (75) expression -> . MINUS term
    (76) expression -> . expression PLUS term
    (77) expression -> . expression MINUS term
    (78) expression -> . func_call_statement
    (79) term -> . factor
    (80) term -> . term MULT factor
    (81) term -> . term DIV factor
    (82) term -> . func_call_statement
    (56) func_call_statement -> . func_call_name LPAREN RPAREN
    (57) func_call_statement -> . func_call_name LPAREN func_call_statement_act1 arg_list RPAREN
    (83) factor -> . var_name
    (84) factor -> . number
    (85) factor -> . LPAREN expression RPAREN
    (86) factor -> . func_call_statement
    (62) func_call_name -> . IDENT
    (87) var_name -> . IDENT
    (88) var_name -> . IDENT LBRACKET expression RBRACKET
    (89) number -> . NUMBER

    MINUS           shift and go to state 60
    LPAREN          shift and go to state 63
    IDENT           shift and go to state 66
    NUMBER          shift and go to state 67

    expression                     shift and go to state 119
    term                           shift and go to state 59
    func_call_statement            shift and go to state 61
    factor                         shift and go to state 62
    func_call_name                 shift and go to state 49
    var_name                       shift and go to state 64
    number                         shift and go to state 65

state 87

    (70) condition -> expression LT . expression
    (74) expression -> . term
    (75) expression -> . MINUS term
    (76) expression -> . expression PLUS term
    (77) expression -> . expression MINUS term
    (78) expression -> . func_call_statement
    (79) term -> . factor
    (80) term -> . term MULT factor
    (81) term -> . term DIV factor
    (82) term -> . func_call_statement
    (56) func_call_statement -> . func_call_name LPAREN RPAREN
    (57) func_call_statement -> . func_call_name LPAREN func_call_statement_act1 arg_list RPAREN
    (83) factor -> . var_name
    (84) factor -> . number
    (85) factor -> . LPAREN expression RPAREN
    (86) factor -> . func_call_statement
    (62) func_call_name -> . IDENT
    (87) var_name -> . IDENT
    (88) var_name -> . IDENT LBRACKET expression RBRACKET
    (89) number -> . NUMBER

    MINUS           shift and go to state 60
    LPAREN          shift and go to state 63
    IDENT           shift and go to state 66
    NUMBER          shift and go to state 67

    expression                     shift and go to state 120
    term                           shift and go to state 59
    func_call_statement            shift and go to state 61
    factor                         shift and go to state 62
    func_call_name                 shift and go to state 49
    var_name                       shift and go to state 64
    number                         shift and go to state 65

state 88

    (71) condition -> expression LE . expression
    (74) expression -> . term
    (75) expression -> . MINUS term
    (76) expression -> . expression PLUS term
    (77) expression -> . expression MINUS term
    (78) expression -> . func_call_statement
    (79) term -> . factor
    (80) term -> . term MULT factor
    (81) term -> . term DIV factor
    (82) term -> . func_call_statement
    (56) func_call_statement -> . func_call_name LPAREN RPAREN
    (57) func_call_statement -> . func_call_name LPAREN func_call_statement_act1 arg_list RPAREN
    (83) factor -> . var_name
    (84) factor -> . number
    (85) factor -> . LPAREN expression RPAREN
    (86) factor -> . func_call_statement
    (62) func_call_name -> . IDENT
    (87) var_name -> . IDENT
    (88) var_name -> . IDENT LBRACKET expression RBRACKET
    (89) number -> . NUMBER

    MINUS           shift and go to state 60
    LPAREN          shift and go to state 63
    IDENT           shift and go to state 66
    NUMBER          shift and go to state 67

    expression                     shift and go to state 121
    term                           shift and go to state 59
    func_call_statement            shift and go to state 61
    factor                         shift and go to state 62
    func_call_name                 shift and go to state 49
    var_name                       shift and go to state 64
    number                         shift and go to state 65

state 89

    (72) condition -> expression GT . expression
    (74) expression -> . term
    (75) expression -> . MINUS term
    (76) expression -> . expression PLUS term
    (77) expression -> . expression MINUS term
    (78) expression -> . func_call_statement
    (79) term -> . factor
    (80) term -> . term MULT factor
    (81) term -> . term DIV factor
    (82) term -> . func_call_statement
    (56) func_call_statement -> . func_call_name LPAREN RPAREN
    (57) func_call_statement -> . func_call_name LPAREN func_call_statement_act1 arg_list RPAREN
    (83) factor -> . var_name
    (84) factor -> . number
    (85) factor -> . LPAREN expression RPAREN
    (86) factor -> . func_call_statement
    (62) func_call_name -> . IDENT
    (87) var_name -> . IDENT
    (88) var_name -> . IDENT LBRACKET expression RBRACKET
    (89) number -> . NUMBER

    MINUS           shift and go to state 60
    LPAREN          shift and go to state 63
    IDENT           shift and go to state 66
    NUMBER          shift and go to state 67

    expression                     shift and go to state 122
    term                           shift and go to state 59
    func_call_statement            shift and go to state 61
    factor                         shift and go to state 62
    func_call_name                 shift and go to state 49
    var_name                       shift and go to state 64
    number                         shift and go to state 65

state 90

    (73) condition -> expression GE . expression
    (74) expression -> . term
    (75) expression -> . MINUS term
    (76) expression -> . expression PLUS term
    (77) expression -> . expression MINUS term
    (78) expression -> . func_call_statement
    (79) term -> . factor
    (80) term -> . term MULT factor
    (81) term -> . term DIV factor
    (82) term -> . func_call_statement
    (56) func_call_statement -> . func_call_name LPAREN RPAREN
    (57) func_call_statement -> . func_call_name LPAREN func_call_statement_act1 arg_list RPAREN
    (83) factor -> . var_name
    (84) factor -> . number
    (85) factor -> . LPAREN expression RPAREN
    (86) factor -> . func_call_statement
    (62) func_call_name -> . IDENT
    (87) var_name -> . IDENT
    (88) var_name -> . IDENT LBRACKET expression RBRACKET
    (89) number -> . NUMBER

    MINUS           shift and go to state 60
    LPAREN          shift and go to state 63
    IDENT           shift and go to state 66
    NUMBER          shift and go to state 67

    expression                     shift and go to state 123
    term                           shift and go to state 59
    func_call_statement            shift and go to state 61
    factor                         shift and go to state 62
    func_call_name                 shift and go to state 49
    var_name                       shift and go to state 64
    number                         shift and go to state 65

state 91

    (76) expression -> expression PLUS . term
    (79) term -> . factor
    (80) term -> . term MULT factor
    (81) term -> . term DIV factor
    (82) term -> . func_call_statement
    (83) factor -> . var_name
    (84) factor -> . number
    (85) factor -> . LPAREN expression RPAREN
    (86) factor -> . func_call_statement
    (56) func_call_statement -> . func_call_name LPAREN RPAREN
    (57) func_call_statement -> . func_call_name LPAREN func_call_statement_act1 arg_list RPAREN
    (87) var_name -> . IDENT
    (88) var_name -> . IDENT LBRACKET expression RBRACKET
    (89) number -> . NUMBER
    (62) func_call_name -> . IDENT

    LPAREN          shift and go to state 63
    IDENT           shift and go to state 97
    NUMBER          shift and go to state 67

    term                           shift and go to state 124
    factor                         shift and go to state 62
    func_call_statement            shift and go to state 96
    var_name                       shift and go to state 64
    number                         shift and go to state 65
    func_call_name                 shift and go to state 49

state 92

    (77) expression -> expression MINUS . term
    (79) term -> . factor
    (80) term -> . term MULT factor
    (81) term -> . term DIV factor
    (82) term -> . func_call_statement
    (83) factor -> . var_name
    (84) factor -> . number
    (85) factor -> . LPAREN expression RPAREN
    (86) factor -> . func_call_statement
    (56) func_call_statement -> . func_call_name LPAREN RPAREN
    (57) func_call_statement -> . func_call_name LPAREN func_call_statement_act1 arg_list RPAREN
    (87) var_name -> . IDENT
    (88) var_name -> . IDENT LBRACKET expression RBRACKET
    (89) number -> . NUMBER
    (62) func_call_name -> . IDENT

    LPAREN          shift and go to state 63
    IDENT           shift and go to state 97
    NUMBER          shift and go to state 67

    term                           shift and go to state 125
    factor                         shift and go to state 62
    func_call_statement            shift and go to state 96
    var_name                       shift and go to state 64
    number                         shift and go to state 65
    func_call_name                 shift and go to state 49

state 93

    (80) term -> term MULT . factor
    (83) factor -> . var_name
    (84) factor -> . number
    (85) factor -> . LPAREN expression RPAREN
    (86) factor -> . func_call_statement
    (87) var_name -> . IDENT
    (88) var_name -> . IDENT LBRACKET expression RBRACKET
    (89) number -> . NUMBER
    (56) func_call_statement -> . func_call_name LPAREN RPAREN
    (57) func_call_statement -> . func_call_name LPAREN func_call_statement_act1 arg_list RPAREN
    (62) func_call_name -> . IDENT

    LPAREN          shift and go to state 63
    IDENT           shift and go to state 97
    NUMBER          shift and go to state 67

    factor                         shift and go to state 126
    var_name                       shift and go to state 64
    number                         shift and go to state 65
    func_call_statement            shift and go to state 127
    func_call_name                 shift and go to state 49

state 94

    (81) term -> term DIV . factor
    (83) factor -> . var_name
    (84) factor -> . number
    (85) factor -> . LPAREN expression RPAREN
    (86) factor -> . func_call_statement
    (87) var_name -> . IDENT
    (88) var_name -> . IDENT LBRACKET expression RBRACKET
    (89) number -> . NUMBER
    (56) func_call_statement -> . func_call_name LPAREN RPAREN
    (57) func_call_statement -> . func_call_name LPAREN func_call_statement_act1 arg_list RPAREN
    (62) func_call_name -> . IDENT

    LPAREN          shift and go to state 63
    IDENT           shift and go to state 97
    NUMBER          shift and go to state 67

    factor                         shift and go to state 128
    var_name                       shift and go to state 64
    number                         shift and go to state 65
    func_call_statement            shift and go to state 127
    func_call_name                 shift and go to state 49

state 95

    (75) expression -> MINUS term .
    (80) term -> term . MULT factor
    (81) term -> term . DIV factor

    EQ              reduce using rule 75 (expression -> MINUS term .)
    NEQ             reduce using rule 75 (expression -> MINUS term .)
    LT              reduce using rule 75 (expression -> MINUS term .)
    LE              reduce using rule 75 (expression -> MINUS term .)
    GT              reduce using rule 75 (expression -> MINUS term .)
    GE              reduce using rule 75 (expression -> MINUS term .)
    PLUS            reduce using rule 75 (expression -> MINUS term .)
    MINUS           reduce using rule 75 (expression -> MINUS term .)
    PERIOD          reduce using rule 75 (expression -> MINUS term .)
    END             reduce using rule 75 (expression -> MINUS term .)
    SEMICOLON       reduce using rule 75 (expression -> MINUS term .)
    ELSE            reduce using rule 75 (expression -> MINUS term .)
    RBRACKET        reduce using rule 75 (expression -> MINUS term .)
    RPAREN          reduce using rule 75 (expression -> MINUS term .)
    THEN            reduce using rule 75 (expression -> MINUS term .)
    DO              reduce using rule 75 (expression -> MINUS term .)
    TO              reduce using rule 75 (expression -> MINUS term .)
    COMMA           reduce using rule 75 (expression -> MINUS term .)
    MULT            shift and go to state 93
    DIV             shift and go to state 94


state 96

    (82) term -> func_call_statement .
    (86) factor -> func_call_statement .

  ! reduce/reduce conflict for MULT resolved using rule 82 (term -> func_call_statement .)
  ! reduce/reduce conflict for DIV resolved using rule 82 (term -> func_call_statement .)
  ! reduce/reduce conflict for EQ resolved using rule 82 (term -> func_call_statement .)
  ! reduce/reduce conflict for NEQ resolved using rule 82 (term -> func_call_statement .)
  ! reduce/reduce conflict for LT resolved using rule 82 (term -> func_call_statement .)
  ! reduce/reduce conflict for LE resolved using rule 82 (term -> func_call_statement .)
  ! reduce/reduce conflict for GT resolved using rule 82 (term -> func_call_statement .)
  ! reduce/reduce conflict for GE resolved using rule 82 (term -> func_call_statement .)
  ! reduce/reduce conflict for PLUS resolved using rule 82 (term -> func_call_statement .)
  ! reduce/reduce conflict for MINUS resolved using rule 82 (term -> func_call_statement .)
  ! reduce/reduce conflict for PERIOD resolved using rule 82 (term -> func_call_statement .)
  ! reduce/reduce conflict for END resolved using rule 82 (term -> func_call_statement .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 82 (term -> func_call_statement .)
  ! reduce/reduce conflict for ELSE resolved using rule 82 (term -> func_call_statement .)
  ! reduce/reduce conflict for RBRACKET resolved using rule 82 (term -> func_call_statement .)
  ! reduce/reduce conflict for RPAREN resolved using rule 82 (term -> func_call_statement .)
  ! reduce/reduce conflict for THEN resolved using rule 82 (term -> func_call_statement .)
  ! reduce/reduce conflict for DO resolved using rule 82 (term -> func_call_statement .)
  ! reduce/reduce conflict for TO resolved using rule 82 (term -> func_call_statement .)
  ! reduce/reduce conflict for COMMA resolved using rule 82 (term -> func_call_statement .)
    MULT            reduce using rule 82 (term -> func_call_statement .)
    DIV             reduce using rule 82 (term -> func_call_statement .)
    EQ              reduce using rule 82 (term -> func_call_statement .)
    NEQ             reduce using rule 82 (term -> func_call_statement .)
    LT              reduce using rule 82 (term -> func_call_statement .)
    LE              reduce using rule 82 (term -> func_call_statement .)
    GT              reduce using rule 82 (term -> func_call_statement .)
    GE              reduce using rule 82 (term -> func_call_statement .)
    PLUS            reduce using rule 82 (term -> func_call_statement .)
    MINUS           reduce using rule 82 (term -> func_call_statement .)
    PERIOD          reduce using rule 82 (term -> func_call_statement .)
    END             reduce using rule 82 (term -> func_call_statement .)
    SEMICOLON       reduce using rule 82 (term -> func_call_statement .)
    ELSE            reduce using rule 82 (term -> func_call_statement .)
    RBRACKET        reduce using rule 82 (term -> func_call_statement .)
    RPAREN          reduce using rule 82 (term -> func_call_statement .)
    THEN            reduce using rule 82 (term -> func_call_statement .)
    DO              reduce using rule 82 (term -> func_call_statement .)
    TO              reduce using rule 82 (term -> func_call_statement .)
    COMMA           reduce using rule 82 (term -> func_call_statement .)

  ! MULT            [ reduce using rule 86 (factor -> func_call_statement .) ]
  ! DIV             [ reduce using rule 86 (factor -> func_call_statement .) ]
  ! EQ              [ reduce using rule 86 (factor -> func_call_statement .) ]
  ! NEQ             [ reduce using rule 86 (factor -> func_call_statement .) ]
  ! LT              [ reduce using rule 86 (factor -> func_call_statement .) ]
  ! LE              [ reduce using rule 86 (factor -> func_call_statement .) ]
  ! GT              [ reduce using rule 86 (factor -> func_call_statement .) ]
  ! GE              [ reduce using rule 86 (factor -> func_call_statement .) ]
  ! PLUS            [ reduce using rule 86 (factor -> func_call_statement .) ]
  ! MINUS           [ reduce using rule 86 (factor -> func_call_statement .) ]
  ! PERIOD          [ reduce using rule 86 (factor -> func_call_statement .) ]
  ! END             [ reduce using rule 86 (factor -> func_call_statement .) ]
  ! SEMICOLON       [ reduce using rule 86 (factor -> func_call_statement .) ]
  ! ELSE            [ reduce using rule 86 (factor -> func_call_statement .) ]
  ! RBRACKET        [ reduce using rule 86 (factor -> func_call_statement .) ]
  ! RPAREN          [ reduce using rule 86 (factor -> func_call_statement .) ]
  ! THEN            [ reduce using rule 86 (factor -> func_call_statement .) ]
  ! DO              [ reduce using rule 86 (factor -> func_call_statement .) ]
  ! TO              [ reduce using rule 86 (factor -> func_call_statement .) ]
  ! COMMA           [ reduce using rule 86 (factor -> func_call_statement .) ]


state 97

    (87) var_name -> IDENT .
    (88) var_name -> IDENT . LBRACKET expression RBRACKET
    (62) func_call_name -> IDENT .

    MULT            reduce using rule 87 (var_name -> IDENT .)
    DIV             reduce using rule 87 (var_name -> IDENT .)
    EQ              reduce using rule 87 (var_name -> IDENT .)
    NEQ             reduce using rule 87 (var_name -> IDENT .)
    LT              reduce using rule 87 (var_name -> IDENT .)
    LE              reduce using rule 87 (var_name -> IDENT .)
    GT              reduce using rule 87 (var_name -> IDENT .)
    GE              reduce using rule 87 (var_name -> IDENT .)
    PLUS            reduce using rule 87 (var_name -> IDENT .)
    MINUS           reduce using rule 87 (var_name -> IDENT .)
    PERIOD          reduce using rule 87 (var_name -> IDENT .)
    END             reduce using rule 87 (var_name -> IDENT .)
    SEMICOLON       reduce using rule 87 (var_name -> IDENT .)
    ELSE            reduce using rule 87 (var_name -> IDENT .)
    RBRACKET        reduce using rule 87 (var_name -> IDENT .)
    RPAREN          reduce using rule 87 (var_name -> IDENT .)
    THEN            reduce using rule 87 (var_name -> IDENT .)
    DO              reduce using rule 87 (var_name -> IDENT .)
    TO              reduce using rule 87 (var_name -> IDENT .)
    COMMA           reduce using rule 87 (var_name -> IDENT .)
    LBRACKET        shift and go to state 99
    LPAREN          reduce using rule 62 (func_call_name -> IDENT .)


state 98

    (85) factor -> LPAREN expression . RPAREN
    (76) expression -> expression . PLUS term
    (77) expression -> expression . MINUS term

    RPAREN          shift and go to state 129
    PLUS            shift and go to state 91
    MINUS           shift and go to state 92


state 99

    (88) var_name -> IDENT LBRACKET . expression RBRACKET
    (74) expression -> . term
    (75) expression -> . MINUS term
    (76) expression -> . expression PLUS term
    (77) expression -> . expression MINUS term
    (78) expression -> . func_call_statement
    (79) term -> . factor
    (80) term -> . term MULT factor
    (81) term -> . term DIV factor
    (82) term -> . func_call_statement
    (56) func_call_statement -> . func_call_name LPAREN RPAREN
    (57) func_call_statement -> . func_call_name LPAREN func_call_statement_act1 arg_list RPAREN
    (83) factor -> . var_name
    (84) factor -> . number
    (85) factor -> . LPAREN expression RPAREN
    (86) factor -> . func_call_statement
    (62) func_call_name -> . IDENT
    (87) var_name -> . IDENT
    (88) var_name -> . IDENT LBRACKET expression RBRACKET
    (89) number -> . NUMBER

    MINUS           shift and go to state 60
    LPAREN          shift and go to state 63
    IDENT           shift and go to state 66
    NUMBER          shift and go to state 67

    expression                     shift and go to state 130
    term                           shift and go to state 59
    func_call_statement            shift and go to state 61
    factor                         shift and go to state 62
    func_call_name                 shift and go to state 49
    var_name                       shift and go to state 64
    number                         shift and go to state 65

state 100

    (48) while_statement -> WHILE while_act1 condition . while_act2 DO statement
    (50) while_act2 -> .

    DO              reduce using rule 50 (while_act2 -> .)

    while_act2                     shift and go to state 131

state 101

    (51) for_statement -> FOR IDENT ASSIGN . expression TO expression for_act1 DO statement
    (74) expression -> . term
    (75) expression -> . MINUS term
    (76) expression -> . expression PLUS term
    (77) expression -> . expression MINUS term
    (78) expression -> . func_call_statement
    (79) term -> . factor
    (80) term -> . term MULT factor
    (81) term -> . term DIV factor
    (82) term -> . func_call_statement
    (56) func_call_statement -> . func_call_name LPAREN RPAREN
    (57) func_call_statement -> . func_call_name LPAREN func_call_statement_act1 arg_list RPAREN
    (83) factor -> . var_name
    (84) factor -> . number
    (85) factor -> . LPAREN expression RPAREN
    (86) factor -> . func_call_statement
    (62) func_call_name -> . IDENT
    (87) var_name -> . IDENT
    (88) var_name -> . IDENT LBRACKET expression RBRACKET
    (89) number -> . NUMBER

    MINUS           shift and go to state 60
    LPAREN          shift and go to state 63
    IDENT           shift and go to state 66
    NUMBER          shift and go to state 67

    expression                     shift and go to state 132
    term                           shift and go to state 59
    func_call_statement            shift and go to state 61
    factor                         shift and go to state 62
    func_call_name                 shift and go to state 49
    var_name                       shift and go to state 64
    number                         shift and go to state 65

state 102

    (53) proc_call_statement -> proc_call_name LPAREN RPAREN .

    PERIOD          reduce using rule 53 (proc_call_statement -> proc_call_name LPAREN RPAREN .)
    END             reduce using rule 53 (proc_call_statement -> proc_call_name LPAREN RPAREN .)
    SEMICOLON       reduce using rule 53 (proc_call_statement -> proc_call_name LPAREN RPAREN .)
    ELSE            reduce using rule 53 (proc_call_statement -> proc_call_name LPAREN RPAREN .)


state 103

    (54) proc_call_statement -> proc_call_name LPAREN proc_call_statement_act1 . arg_list RPAREN
    (59) arg_list -> . expression
    (60) arg_list -> . arg_list COMMA expression
    (74) expression -> . term
    (75) expression -> . MINUS term
    (76) expression -> . expression PLUS term
    (77) expression -> . expression MINUS term
    (78) expression -> . func_call_statement
    (79) term -> . factor
    (80) term -> . term MULT factor
    (81) term -> . term DIV factor
    (82) term -> . func_call_statement
    (56) func_call_statement -> . func_call_name LPAREN RPAREN
    (57) func_call_statement -> . func_call_name LPAREN func_call_statement_act1 arg_list RPAREN
    (83) factor -> . var_name
    (84) factor -> . number
    (85) factor -> . LPAREN expression RPAREN
    (86) factor -> . func_call_statement
    (62) func_call_name -> . IDENT
    (87) var_name -> . IDENT
    (88) var_name -> . IDENT LBRACKET expression RBRACKET
    (89) number -> . NUMBER

    MINUS           shift and go to state 60
    LPAREN          shift and go to state 63
    IDENT           shift and go to state 66
    NUMBER          shift and go to state 67

    arg_list                       shift and go to state 133
    expression                     shift and go to state 134
    term                           shift and go to state 59
    func_call_statement            shift and go to state 61
    factor                         shift and go to state 62
    func_call_name                 shift and go to state 49
    var_name                       shift and go to state 64
    number                         shift and go to state 65

state 104

    (63) block_statement -> BEGIN statement_list END .

    PERIOD          reduce using rule 63 (block_statement -> BEGIN statement_list END .)
    END             reduce using rule 63 (block_statement -> BEGIN statement_list END .)
    SEMICOLON       reduce using rule 63 (block_statement -> BEGIN statement_list END .)
    ELSE            reduce using rule 63 (block_statement -> BEGIN statement_list END .)


state 105

    (29) statement_list -> statement_list SEMICOLON . statement
    (31) statement -> . assignment_statement
    (32) statement -> . if_statement
    (33) statement -> . while_statement
    (34) statement -> . for_statement
    (35) statement -> . proc_call_statement
    (36) statement -> . null_statement
    (37) statement -> . block_statement
    (38) statement -> . read_statement
    (39) statement -> . write_statement
    (40) statement -> . func_call_statement
    (41) assignment_statement -> . IDENT ASSIGN expression
    (42) assignment_statement -> . IDENT LBRACKET expression RBRACKET ASSIGN expression
    (43) if_statement -> . IF condition if_act1 THEN statement else_statement
    (48) while_statement -> . WHILE while_act1 condition while_act2 DO statement
    (51) for_statement -> . FOR IDENT ASSIGN expression TO expression for_act1 DO statement
    (53) proc_call_statement -> . proc_call_name LPAREN RPAREN
    (54) proc_call_statement -> . proc_call_name LPAREN proc_call_statement_act1 arg_list RPAREN
    (67) null_statement -> .
    (63) block_statement -> . BEGIN statement_list END
    (64) read_statement -> . READ LPAREN IDENT RPAREN
    (65) read_statement -> . READ LPAREN IDENT LBRACKET expression RBRACKET RPAREN
    (66) write_statement -> . WRITE LPAREN expression RPAREN
    (56) func_call_statement -> . func_call_name LPAREN RPAREN
    (57) func_call_statement -> . func_call_name LPAREN func_call_statement_act1 arg_list RPAREN
    (61) proc_call_name -> . IDENT
    (62) func_call_name -> . IDENT

    IDENT           shift and go to state 41
    IF              shift and go to state 42
    WHILE           shift and go to state 43
    FOR             shift and go to state 44
    END             reduce using rule 67 (null_statement -> .)
    SEMICOLON       reduce using rule 67 (null_statement -> .)
    BEGIN           shift and go to state 46
    READ            shift and go to state 47
    WRITE           shift and go to state 48

    statement                      shift and go to state 135
    assignment_statement           shift and go to state 31
    if_statement                   shift and go to state 32
    while_statement                shift and go to state 33
    for_statement                  shift and go to state 34
    proc_call_statement            shift and go to state 35
    null_statement                 shift and go to state 36
    block_statement                shift and go to state 37
    read_statement                 shift and go to state 38
    write_statement                shift and go to state 39
    func_call_statement            shift and go to state 40
    proc_call_name                 shift and go to state 45
    func_call_name                 shift and go to state 49

state 106

    (64) read_statement -> READ LPAREN IDENT . RPAREN
    (65) read_statement -> READ LPAREN IDENT . LBRACKET expression RBRACKET RPAREN

    RPAREN          shift and go to state 136
    LBRACKET        shift and go to state 137


state 107

    (66) write_statement -> WRITE LPAREN expression . RPAREN
    (76) expression -> expression . PLUS term
    (77) expression -> expression . MINUS term

    RPAREN          shift and go to state 138
    PLUS            shift and go to state 91
    MINUS           shift and go to state 92


state 108

    (56) func_call_statement -> func_call_name LPAREN RPAREN .

    PERIOD          reduce using rule 56 (func_call_statement -> func_call_name LPAREN RPAREN .)
    EQ              reduce using rule 56 (func_call_statement -> func_call_name LPAREN RPAREN .)
    NEQ             reduce using rule 56 (func_call_statement -> func_call_name LPAREN RPAREN .)
    LT              reduce using rule 56 (func_call_statement -> func_call_name LPAREN RPAREN .)
    LE              reduce using rule 56 (func_call_statement -> func_call_name LPAREN RPAREN .)
    GT              reduce using rule 56 (func_call_statement -> func_call_name LPAREN RPAREN .)
    GE              reduce using rule 56 (func_call_statement -> func_call_name LPAREN RPAREN .)
    PLUS            reduce using rule 56 (func_call_statement -> func_call_name LPAREN RPAREN .)
    MINUS           reduce using rule 56 (func_call_statement -> func_call_name LPAREN RPAREN .)
    MULT            reduce using rule 56 (func_call_statement -> func_call_name LPAREN RPAREN .)
    DIV             reduce using rule 56 (func_call_statement -> func_call_name LPAREN RPAREN .)
    END             reduce using rule 56 (func_call_statement -> func_call_name LPAREN RPAREN .)
    SEMICOLON       reduce using rule 56 (func_call_statement -> func_call_name LPAREN RPAREN .)
    ELSE            reduce using rule 56 (func_call_statement -> func_call_name LPAREN RPAREN .)
    RBRACKET        reduce using rule 56 (func_call_statement -> func_call_name LPAREN RPAREN .)
    RPAREN          reduce using rule 56 (func_call_statement -> func_call_name LPAREN RPAREN .)
    THEN            reduce using rule 56 (func_call_statement -> func_call_name LPAREN RPAREN .)
    DO              reduce using rule 56 (func_call_statement -> func_call_name LPAREN RPAREN .)
    TO              reduce using rule 56 (func_call_statement -> func_call_name LPAREN RPAREN .)
    COMMA           reduce using rule 56 (func_call_statement -> func_call_name LPAREN RPAREN .)


state 109

    (57) func_call_statement -> func_call_name LPAREN func_call_statement_act1 . arg_list RPAREN
    (59) arg_list -> . expression
    (60) arg_list -> . arg_list COMMA expression
    (74) expression -> . term
    (75) expression -> . MINUS term
    (76) expression -> . expression PLUS term
    (77) expression -> . expression MINUS term
    (78) expression -> . func_call_statement
    (79) term -> . factor
    (80) term -> . term MULT factor
    (81) term -> . term DIV factor
    (82) term -> . func_call_statement
    (56) func_call_statement -> . func_call_name LPAREN RPAREN
    (57) func_call_statement -> . func_call_name LPAREN func_call_statement_act1 arg_list RPAREN
    (83) factor -> . var_name
    (84) factor -> . number
    (85) factor -> . LPAREN expression RPAREN
    (86) factor -> . func_call_statement
    (62) func_call_name -> . IDENT
    (87) var_name -> . IDENT
    (88) var_name -> . IDENT LBRACKET expression RBRACKET
    (89) number -> . NUMBER

    MINUS           shift and go to state 60
    LPAREN          shift and go to state 63
    IDENT           shift and go to state 66
    NUMBER          shift and go to state 67

    func_call_name                 shift and go to state 49
    arg_list                       shift and go to state 139
    expression                     shift and go to state 134
    term                           shift and go to state 59
    func_call_statement            shift and go to state 61
    factor                         shift and go to state 62
    var_name                       shift and go to state 64
    number                         shift and go to state 65

state 110

    (15) proc_decl -> PROCEDURE proc_name LPAREN RPAREN SEMICOLON . inblock
    (19) inblock -> . inblock_act1 var_decl_part inblock_act2 statement
    (20) inblock_act1 -> .

    VAR             reduce using rule 20 (inblock_act1 -> .)
    IDENT           reduce using rule 20 (inblock_act1 -> .)
    IF              reduce using rule 20 (inblock_act1 -> .)
    WHILE           reduce using rule 20 (inblock_act1 -> .)
    FOR             reduce using rule 20 (inblock_act1 -> .)
    BEGIN           reduce using rule 20 (inblock_act1 -> .)
    READ            reduce using rule 20 (inblock_act1 -> .)
    WRITE           reduce using rule 20 (inblock_act1 -> .)
    SEMICOLON       reduce using rule 20 (inblock_act1 -> .)

    inblock                        shift and go to state 140
    inblock_act1                   shift and go to state 141

state 111

    (16) proc_decl -> PROCEDURE proc_name LPAREN proc_decl_act1 id_list . RPAREN SEMICOLON inblock
    (91) id_list -> id_list . COMMA IDENT
    (92) id_list -> id_list . COMMA IDENT LBRACKET NUMBER INTERVAL NUMBER RBRACKET

    RPAREN          shift and go to state 142
    COMMA           shift and go to state 28


state 112

    (22) func_decl -> FUNCTION func_name LPAREN RPAREN SEMICOLON . func_inblock
    (26) func_inblock -> . func_inblock_act1 var_decl_part func_inblock_act2 statement
    (27) func_inblock_act1 -> .

    VAR             reduce using rule 27 (func_inblock_act1 -> .)
    IDENT           reduce using rule 27 (func_inblock_act1 -> .)
    IF              reduce using rule 27 (func_inblock_act1 -> .)
    WHILE           reduce using rule 27 (func_inblock_act1 -> .)
    FOR             reduce using rule 27 (func_inblock_act1 -> .)
    BEGIN           reduce using rule 27 (func_inblock_act1 -> .)
    READ            reduce using rule 27 (func_inblock_act1 -> .)
    WRITE           reduce using rule 27 (func_inblock_act1 -> .)
    SEMICOLON       reduce using rule 27 (func_inblock_act1 -> .)

    func_inblock                   shift and go to state 143
    func_inblock_act1              shift and go to state 144

state 113

    (23) func_decl -> FUNCTION func_name LPAREN func_decl_act1 id_list . RPAREN SEMICOLON func_inblock
    (91) id_list -> id_list . COMMA IDENT
    (92) id_list -> id_list . COMMA IDENT LBRACKET NUMBER INTERVAL NUMBER RBRACKET

    RPAREN          shift and go to state 145
    COMMA           shift and go to state 28


state 114

    (92) id_list -> id_list COMMA IDENT LBRACKET NUMBER . INTERVAL NUMBER RBRACKET

    INTERVAL        shift and go to state 146


state 115

    (93) id_list -> IDENT LBRACKET NUMBER INTERVAL NUMBER . RBRACKET COMMA id_list id_list_act1

    RBRACKET        shift and go to state 147


state 116

    (42) assignment_statement -> IDENT LBRACKET expression RBRACKET . ASSIGN expression

    ASSIGN          shift and go to state 148


state 117

    (43) if_statement -> IF condition if_act1 THEN . statement else_statement
    (31) statement -> . assignment_statement
    (32) statement -> . if_statement
    (33) statement -> . while_statement
    (34) statement -> . for_statement
    (35) statement -> . proc_call_statement
    (36) statement -> . null_statement
    (37) statement -> . block_statement
    (38) statement -> . read_statement
    (39) statement -> . write_statement
    (40) statement -> . func_call_statement
    (41) assignment_statement -> . IDENT ASSIGN expression
    (42) assignment_statement -> . IDENT LBRACKET expression RBRACKET ASSIGN expression
    (43) if_statement -> . IF condition if_act1 THEN statement else_statement
    (48) while_statement -> . WHILE while_act1 condition while_act2 DO statement
    (51) for_statement -> . FOR IDENT ASSIGN expression TO expression for_act1 DO statement
    (53) proc_call_statement -> . proc_call_name LPAREN RPAREN
    (54) proc_call_statement -> . proc_call_name LPAREN proc_call_statement_act1 arg_list RPAREN
    (67) null_statement -> .
    (63) block_statement -> . BEGIN statement_list END
    (64) read_statement -> . READ LPAREN IDENT RPAREN
    (65) read_statement -> . READ LPAREN IDENT LBRACKET expression RBRACKET RPAREN
    (66) write_statement -> . WRITE LPAREN expression RPAREN
    (56) func_call_statement -> . func_call_name LPAREN RPAREN
    (57) func_call_statement -> . func_call_name LPAREN func_call_statement_act1 arg_list RPAREN
    (61) proc_call_name -> . IDENT
    (62) func_call_name -> . IDENT

    IDENT           shift and go to state 41
    IF              shift and go to state 42
    WHILE           shift and go to state 43
    FOR             shift and go to state 44
    ELSE            reduce using rule 67 (null_statement -> .)
    PERIOD          reduce using rule 67 (null_statement -> .)
    END             reduce using rule 67 (null_statement -> .)
    SEMICOLON       reduce using rule 67 (null_statement -> .)
    BEGIN           shift and go to state 46
    READ            shift and go to state 47
    WRITE           shift and go to state 48

    statement                      shift and go to state 149
    assignment_statement           shift and go to state 31
    if_statement                   shift and go to state 32
    while_statement                shift and go to state 33
    for_statement                  shift and go to state 34
    proc_call_statement            shift and go to state 35
    null_statement                 shift and go to state 36
    block_statement                shift and go to state 37
    read_statement                 shift and go to state 38
    write_statement                shift and go to state 39
    func_call_statement            shift and go to state 40
    proc_call_name                 shift and go to state 45
    func_call_name                 shift and go to state 49

state 118

    (68) condition -> expression EQ expression .
    (76) expression -> expression . PLUS term
    (77) expression -> expression . MINUS term

    THEN            reduce using rule 68 (condition -> expression EQ expression .)
    DO              reduce using rule 68 (condition -> expression EQ expression .)
    PLUS            shift and go to state 91
    MINUS           shift and go to state 92


state 119

    (69) condition -> expression NEQ expression .
    (76) expression -> expression . PLUS term
    (77) expression -> expression . MINUS term

    THEN            reduce using rule 69 (condition -> expression NEQ expression .)
    DO              reduce using rule 69 (condition -> expression NEQ expression .)
    PLUS            shift and go to state 91
    MINUS           shift and go to state 92


state 120

    (70) condition -> expression LT expression .
    (76) expression -> expression . PLUS term
    (77) expression -> expression . MINUS term

    THEN            reduce using rule 70 (condition -> expression LT expression .)
    DO              reduce using rule 70 (condition -> expression LT expression .)
    PLUS            shift and go to state 91
    MINUS           shift and go to state 92


state 121

    (71) condition -> expression LE expression .
    (76) expression -> expression . PLUS term
    (77) expression -> expression . MINUS term

    THEN            reduce using rule 71 (condition -> expression LE expression .)
    DO              reduce using rule 71 (condition -> expression LE expression .)
    PLUS            shift and go to state 91
    MINUS           shift and go to state 92


state 122

    (72) condition -> expression GT expression .
    (76) expression -> expression . PLUS term
    (77) expression -> expression . MINUS term

    THEN            reduce using rule 72 (condition -> expression GT expression .)
    DO              reduce using rule 72 (condition -> expression GT expression .)
    PLUS            shift and go to state 91
    MINUS           shift and go to state 92


state 123

    (73) condition -> expression GE expression .
    (76) expression -> expression . PLUS term
    (77) expression -> expression . MINUS term

    THEN            reduce using rule 73 (condition -> expression GE expression .)
    DO              reduce using rule 73 (condition -> expression GE expression .)
    PLUS            shift and go to state 91
    MINUS           shift and go to state 92


state 124

    (76) expression -> expression PLUS term .
    (80) term -> term . MULT factor
    (81) term -> term . DIV factor

    EQ              reduce using rule 76 (expression -> expression PLUS term .)
    NEQ             reduce using rule 76 (expression -> expression PLUS term .)
    LT              reduce using rule 76 (expression -> expression PLUS term .)
    LE              reduce using rule 76 (expression -> expression PLUS term .)
    GT              reduce using rule 76 (expression -> expression PLUS term .)
    GE              reduce using rule 76 (expression -> expression PLUS term .)
    PLUS            reduce using rule 76 (expression -> expression PLUS term .)
    MINUS           reduce using rule 76 (expression -> expression PLUS term .)
    PERIOD          reduce using rule 76 (expression -> expression PLUS term .)
    END             reduce using rule 76 (expression -> expression PLUS term .)
    SEMICOLON       reduce using rule 76 (expression -> expression PLUS term .)
    ELSE            reduce using rule 76 (expression -> expression PLUS term .)
    RBRACKET        reduce using rule 76 (expression -> expression PLUS term .)
    RPAREN          reduce using rule 76 (expression -> expression PLUS term .)
    THEN            reduce using rule 76 (expression -> expression PLUS term .)
    DO              reduce using rule 76 (expression -> expression PLUS term .)
    TO              reduce using rule 76 (expression -> expression PLUS term .)
    COMMA           reduce using rule 76 (expression -> expression PLUS term .)
    MULT            shift and go to state 93
    DIV             shift and go to state 94


state 125

    (77) expression -> expression MINUS term .
    (80) term -> term . MULT factor
    (81) term -> term . DIV factor

    EQ              reduce using rule 77 (expression -> expression MINUS term .)
    NEQ             reduce using rule 77 (expression -> expression MINUS term .)
    LT              reduce using rule 77 (expression -> expression MINUS term .)
    LE              reduce using rule 77 (expression -> expression MINUS term .)
    GT              reduce using rule 77 (expression -> expression MINUS term .)
    GE              reduce using rule 77 (expression -> expression MINUS term .)
    PLUS            reduce using rule 77 (expression -> expression MINUS term .)
    MINUS           reduce using rule 77 (expression -> expression MINUS term .)
    PERIOD          reduce using rule 77 (expression -> expression MINUS term .)
    END             reduce using rule 77 (expression -> expression MINUS term .)
    SEMICOLON       reduce using rule 77 (expression -> expression MINUS term .)
    ELSE            reduce using rule 77 (expression -> expression MINUS term .)
    RBRACKET        reduce using rule 77 (expression -> expression MINUS term .)
    RPAREN          reduce using rule 77 (expression -> expression MINUS term .)
    THEN            reduce using rule 77 (expression -> expression MINUS term .)
    DO              reduce using rule 77 (expression -> expression MINUS term .)
    TO              reduce using rule 77 (expression -> expression MINUS term .)
    COMMA           reduce using rule 77 (expression -> expression MINUS term .)
    MULT            shift and go to state 93
    DIV             shift and go to state 94


state 126

    (80) term -> term MULT factor .

    MULT            reduce using rule 80 (term -> term MULT factor .)
    DIV             reduce using rule 80 (term -> term MULT factor .)
    EQ              reduce using rule 80 (term -> term MULT factor .)
    NEQ             reduce using rule 80 (term -> term MULT factor .)
    LT              reduce using rule 80 (term -> term MULT factor .)
    LE              reduce using rule 80 (term -> term MULT factor .)
    GT              reduce using rule 80 (term -> term MULT factor .)
    GE              reduce using rule 80 (term -> term MULT factor .)
    PLUS            reduce using rule 80 (term -> term MULT factor .)
    MINUS           reduce using rule 80 (term -> term MULT factor .)
    PERIOD          reduce using rule 80 (term -> term MULT factor .)
    END             reduce using rule 80 (term -> term MULT factor .)
    SEMICOLON       reduce using rule 80 (term -> term MULT factor .)
    ELSE            reduce using rule 80 (term -> term MULT factor .)
    RBRACKET        reduce using rule 80 (term -> term MULT factor .)
    RPAREN          reduce using rule 80 (term -> term MULT factor .)
    THEN            reduce using rule 80 (term -> term MULT factor .)
    DO              reduce using rule 80 (term -> term MULT factor .)
    TO              reduce using rule 80 (term -> term MULT factor .)
    COMMA           reduce using rule 80 (term -> term MULT factor .)


state 127

    (86) factor -> func_call_statement .

    MULT            reduce using rule 86 (factor -> func_call_statement .)
    DIV             reduce using rule 86 (factor -> func_call_statement .)
    EQ              reduce using rule 86 (factor -> func_call_statement .)
    NEQ             reduce using rule 86 (factor -> func_call_statement .)
    LT              reduce using rule 86 (factor -> func_call_statement .)
    LE              reduce using rule 86 (factor -> func_call_statement .)
    GT              reduce using rule 86 (factor -> func_call_statement .)
    GE              reduce using rule 86 (factor -> func_call_statement .)
    PLUS            reduce using rule 86 (factor -> func_call_statement .)
    MINUS           reduce using rule 86 (factor -> func_call_statement .)
    PERIOD          reduce using rule 86 (factor -> func_call_statement .)
    END             reduce using rule 86 (factor -> func_call_statement .)
    SEMICOLON       reduce using rule 86 (factor -> func_call_statement .)
    ELSE            reduce using rule 86 (factor -> func_call_statement .)
    RBRACKET        reduce using rule 86 (factor -> func_call_statement .)
    RPAREN          reduce using rule 86 (factor -> func_call_statement .)
    THEN            reduce using rule 86 (factor -> func_call_statement .)
    DO              reduce using rule 86 (factor -> func_call_statement .)
    TO              reduce using rule 86 (factor -> func_call_statement .)
    COMMA           reduce using rule 86 (factor -> func_call_statement .)


state 128

    (81) term -> term DIV factor .

    MULT            reduce using rule 81 (term -> term DIV factor .)
    DIV             reduce using rule 81 (term -> term DIV factor .)
    EQ              reduce using rule 81 (term -> term DIV factor .)
    NEQ             reduce using rule 81 (term -> term DIV factor .)
    LT              reduce using rule 81 (term -> term DIV factor .)
    LE              reduce using rule 81 (term -> term DIV factor .)
    GT              reduce using rule 81 (term -> term DIV factor .)
    GE              reduce using rule 81 (term -> term DIV factor .)
    PLUS            reduce using rule 81 (term -> term DIV factor .)
    MINUS           reduce using rule 81 (term -> term DIV factor .)
    PERIOD          reduce using rule 81 (term -> term DIV factor .)
    END             reduce using rule 81 (term -> term DIV factor .)
    SEMICOLON       reduce using rule 81 (term -> term DIV factor .)
    ELSE            reduce using rule 81 (term -> term DIV factor .)
    RBRACKET        reduce using rule 81 (term -> term DIV factor .)
    RPAREN          reduce using rule 81 (term -> term DIV factor .)
    THEN            reduce using rule 81 (term -> term DIV factor .)
    DO              reduce using rule 81 (term -> term DIV factor .)
    TO              reduce using rule 81 (term -> term DIV factor .)
    COMMA           reduce using rule 81 (term -> term DIV factor .)


state 129

    (85) factor -> LPAREN expression RPAREN .

    MULT            reduce using rule 85 (factor -> LPAREN expression RPAREN .)
    DIV             reduce using rule 85 (factor -> LPAREN expression RPAREN .)
    EQ              reduce using rule 85 (factor -> LPAREN expression RPAREN .)
    NEQ             reduce using rule 85 (factor -> LPAREN expression RPAREN .)
    LT              reduce using rule 85 (factor -> LPAREN expression RPAREN .)
    LE              reduce using rule 85 (factor -> LPAREN expression RPAREN .)
    GT              reduce using rule 85 (factor -> LPAREN expression RPAREN .)
    GE              reduce using rule 85 (factor -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 85 (factor -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 85 (factor -> LPAREN expression RPAREN .)
    PERIOD          reduce using rule 85 (factor -> LPAREN expression RPAREN .)
    END             reduce using rule 85 (factor -> LPAREN expression RPAREN .)
    SEMICOLON       reduce using rule 85 (factor -> LPAREN expression RPAREN .)
    ELSE            reduce using rule 85 (factor -> LPAREN expression RPAREN .)
    RBRACKET        reduce using rule 85 (factor -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 85 (factor -> LPAREN expression RPAREN .)
    THEN            reduce using rule 85 (factor -> LPAREN expression RPAREN .)
    DO              reduce using rule 85 (factor -> LPAREN expression RPAREN .)
    TO              reduce using rule 85 (factor -> LPAREN expression RPAREN .)
    COMMA           reduce using rule 85 (factor -> LPAREN expression RPAREN .)


state 130

    (88) var_name -> IDENT LBRACKET expression . RBRACKET
    (76) expression -> expression . PLUS term
    (77) expression -> expression . MINUS term

    RBRACKET        shift and go to state 150
    PLUS            shift and go to state 91
    MINUS           shift and go to state 92


state 131

    (48) while_statement -> WHILE while_act1 condition while_act2 . DO statement

    DO              shift and go to state 151


state 132

    (51) for_statement -> FOR IDENT ASSIGN expression . TO expression for_act1 DO statement
    (76) expression -> expression . PLUS term
    (77) expression -> expression . MINUS term

    TO              shift and go to state 152
    PLUS            shift and go to state 91
    MINUS           shift and go to state 92


state 133

    (54) proc_call_statement -> proc_call_name LPAREN proc_call_statement_act1 arg_list . RPAREN
    (60) arg_list -> arg_list . COMMA expression

    RPAREN          shift and go to state 153
    COMMA           shift and go to state 154


state 134

    (59) arg_list -> expression .
    (76) expression -> expression . PLUS term
    (77) expression -> expression . MINUS term

    RPAREN          reduce using rule 59 (arg_list -> expression .)
    COMMA           reduce using rule 59 (arg_list -> expression .)
    PLUS            shift and go to state 91
    MINUS           shift and go to state 92


state 135

    (29) statement_list -> statement_list SEMICOLON statement .

    END             reduce using rule 29 (statement_list -> statement_list SEMICOLON statement .)
    SEMICOLON       reduce using rule 29 (statement_list -> statement_list SEMICOLON statement .)


state 136

    (64) read_statement -> READ LPAREN IDENT RPAREN .

    PERIOD          reduce using rule 64 (read_statement -> READ LPAREN IDENT RPAREN .)
    END             reduce using rule 64 (read_statement -> READ LPAREN IDENT RPAREN .)
    SEMICOLON       reduce using rule 64 (read_statement -> READ LPAREN IDENT RPAREN .)
    ELSE            reduce using rule 64 (read_statement -> READ LPAREN IDENT RPAREN .)


state 137

    (65) read_statement -> READ LPAREN IDENT LBRACKET . expression RBRACKET RPAREN
    (74) expression -> . term
    (75) expression -> . MINUS term
    (76) expression -> . expression PLUS term
    (77) expression -> . expression MINUS term
    (78) expression -> . func_call_statement
    (79) term -> . factor
    (80) term -> . term MULT factor
    (81) term -> . term DIV factor
    (82) term -> . func_call_statement
    (56) func_call_statement -> . func_call_name LPAREN RPAREN
    (57) func_call_statement -> . func_call_name LPAREN func_call_statement_act1 arg_list RPAREN
    (83) factor -> . var_name
    (84) factor -> . number
    (85) factor -> . LPAREN expression RPAREN
    (86) factor -> . func_call_statement
    (62) func_call_name -> . IDENT
    (87) var_name -> . IDENT
    (88) var_name -> . IDENT LBRACKET expression RBRACKET
    (89) number -> . NUMBER

    MINUS           shift and go to state 60
    LPAREN          shift and go to state 63
    IDENT           shift and go to state 66
    NUMBER          shift and go to state 67

    expression                     shift and go to state 155
    term                           shift and go to state 59
    func_call_statement            shift and go to state 61
    factor                         shift and go to state 62
    func_call_name                 shift and go to state 49
    var_name                       shift and go to state 64
    number                         shift and go to state 65

state 138

    (66) write_statement -> WRITE LPAREN expression RPAREN .

    PERIOD          reduce using rule 66 (write_statement -> WRITE LPAREN expression RPAREN .)
    END             reduce using rule 66 (write_statement -> WRITE LPAREN expression RPAREN .)
    SEMICOLON       reduce using rule 66 (write_statement -> WRITE LPAREN expression RPAREN .)
    ELSE            reduce using rule 66 (write_statement -> WRITE LPAREN expression RPAREN .)


state 139

    (57) func_call_statement -> func_call_name LPAREN func_call_statement_act1 arg_list . RPAREN
    (60) arg_list -> arg_list . COMMA expression

    RPAREN          shift and go to state 156
    COMMA           shift and go to state 154


state 140

    (15) proc_decl -> PROCEDURE proc_name LPAREN RPAREN SEMICOLON inblock .

    SEMICOLON       reduce using rule 15 (proc_decl -> PROCEDURE proc_name LPAREN RPAREN SEMICOLON inblock .)


state 141

    (19) inblock -> inblock_act1 . var_decl_part inblock_act2 statement
    (4) var_decl_part -> . var_decl_list SEMICOLON
    (5) var_decl_part -> .
    (6) var_decl_list -> . var_decl_list SEMICOLON var_decl
    (7) var_decl_list -> . var_decl
    (8) var_decl -> . VAR id_list

    IDENT           reduce using rule 5 (var_decl_part -> .)
    IF              reduce using rule 5 (var_decl_part -> .)
    WHILE           reduce using rule 5 (var_decl_part -> .)
    FOR             reduce using rule 5 (var_decl_part -> .)
    BEGIN           reduce using rule 5 (var_decl_part -> .)
    READ            reduce using rule 5 (var_decl_part -> .)
    WRITE           reduce using rule 5 (var_decl_part -> .)
    SEMICOLON       reduce using rule 5 (var_decl_part -> .)
    VAR             shift and go to state 9

    var_decl_part                  shift and go to state 157
    var_decl_list                  shift and go to state 7
    var_decl                       shift and go to state 8

state 142

    (16) proc_decl -> PROCEDURE proc_name LPAREN proc_decl_act1 id_list RPAREN . SEMICOLON inblock

    SEMICOLON       shift and go to state 158


state 143

    (22) func_decl -> FUNCTION func_name LPAREN RPAREN SEMICOLON func_inblock .

    SEMICOLON       reduce using rule 22 (func_decl -> FUNCTION func_name LPAREN RPAREN SEMICOLON func_inblock .)


state 144

    (26) func_inblock -> func_inblock_act1 . var_decl_part func_inblock_act2 statement
    (4) var_decl_part -> . var_decl_list SEMICOLON
    (5) var_decl_part -> .
    (6) var_decl_list -> . var_decl_list SEMICOLON var_decl
    (7) var_decl_list -> . var_decl
    (8) var_decl -> . VAR id_list

    IDENT           reduce using rule 5 (var_decl_part -> .)
    IF              reduce using rule 5 (var_decl_part -> .)
    WHILE           reduce using rule 5 (var_decl_part -> .)
    FOR             reduce using rule 5 (var_decl_part -> .)
    BEGIN           reduce using rule 5 (var_decl_part -> .)
    READ            reduce using rule 5 (var_decl_part -> .)
    WRITE           reduce using rule 5 (var_decl_part -> .)
    SEMICOLON       reduce using rule 5 (var_decl_part -> .)
    VAR             shift and go to state 9

    var_decl_part                  shift and go to state 159
    var_decl_list                  shift and go to state 7
    var_decl                       shift and go to state 8

state 145

    (23) func_decl -> FUNCTION func_name LPAREN func_decl_act1 id_list RPAREN . SEMICOLON func_inblock

    SEMICOLON       shift and go to state 160


state 146

    (92) id_list -> id_list COMMA IDENT LBRACKET NUMBER INTERVAL . NUMBER RBRACKET

    NUMBER          shift and go to state 161


state 147

    (93) id_list -> IDENT LBRACKET NUMBER INTERVAL NUMBER RBRACKET . COMMA id_list id_list_act1

    COMMA           shift and go to state 162


state 148

    (42) assignment_statement -> IDENT LBRACKET expression RBRACKET ASSIGN . expression
    (74) expression -> . term
    (75) expression -> . MINUS term
    (76) expression -> . expression PLUS term
    (77) expression -> . expression MINUS term
    (78) expression -> . func_call_statement
    (79) term -> . factor
    (80) term -> . term MULT factor
    (81) term -> . term DIV factor
    (82) term -> . func_call_statement
    (56) func_call_statement -> . func_call_name LPAREN RPAREN
    (57) func_call_statement -> . func_call_name LPAREN func_call_statement_act1 arg_list RPAREN
    (83) factor -> . var_name
    (84) factor -> . number
    (85) factor -> . LPAREN expression RPAREN
    (86) factor -> . func_call_statement
    (62) func_call_name -> . IDENT
    (87) var_name -> . IDENT
    (88) var_name -> . IDENT LBRACKET expression RBRACKET
    (89) number -> . NUMBER

    MINUS           shift and go to state 60
    LPAREN          shift and go to state 63
    IDENT           shift and go to state 66
    NUMBER          shift and go to state 67

    expression                     shift and go to state 163
    term                           shift and go to state 59
    func_call_statement            shift and go to state 61
    factor                         shift and go to state 62
    func_call_name                 shift and go to state 49
    var_name                       shift and go to state 64
    number                         shift and go to state 65

state 149

    (43) if_statement -> IF condition if_act1 THEN statement . else_statement
    (45) else_statement -> . ELSE else_act1 statement
    (46) else_statement -> .

  ! shift/reduce conflict for ELSE resolved as shift
    ELSE            shift and go to state 165
    PERIOD          reduce using rule 46 (else_statement -> .)
    END             reduce using rule 46 (else_statement -> .)
    SEMICOLON       reduce using rule 46 (else_statement -> .)

  ! ELSE            [ reduce using rule 46 (else_statement -> .) ]

    else_statement                 shift and go to state 164

state 150

    (88) var_name -> IDENT LBRACKET expression RBRACKET .

    MULT            reduce using rule 88 (var_name -> IDENT LBRACKET expression RBRACKET .)
    DIV             reduce using rule 88 (var_name -> IDENT LBRACKET expression RBRACKET .)
    EQ              reduce using rule 88 (var_name -> IDENT LBRACKET expression RBRACKET .)
    NEQ             reduce using rule 88 (var_name -> IDENT LBRACKET expression RBRACKET .)
    LT              reduce using rule 88 (var_name -> IDENT LBRACKET expression RBRACKET .)
    LE              reduce using rule 88 (var_name -> IDENT LBRACKET expression RBRACKET .)
    GT              reduce using rule 88 (var_name -> IDENT LBRACKET expression RBRACKET .)
    GE              reduce using rule 88 (var_name -> IDENT LBRACKET expression RBRACKET .)
    PLUS            reduce using rule 88 (var_name -> IDENT LBRACKET expression RBRACKET .)
    MINUS           reduce using rule 88 (var_name -> IDENT LBRACKET expression RBRACKET .)
    PERIOD          reduce using rule 88 (var_name -> IDENT LBRACKET expression RBRACKET .)
    END             reduce using rule 88 (var_name -> IDENT LBRACKET expression RBRACKET .)
    SEMICOLON       reduce using rule 88 (var_name -> IDENT LBRACKET expression RBRACKET .)
    ELSE            reduce using rule 88 (var_name -> IDENT LBRACKET expression RBRACKET .)
    RBRACKET        reduce using rule 88 (var_name -> IDENT LBRACKET expression RBRACKET .)
    RPAREN          reduce using rule 88 (var_name -> IDENT LBRACKET expression RBRACKET .)
    THEN            reduce using rule 88 (var_name -> IDENT LBRACKET expression RBRACKET .)
    DO              reduce using rule 88 (var_name -> IDENT LBRACKET expression RBRACKET .)
    TO              reduce using rule 88 (var_name -> IDENT LBRACKET expression RBRACKET .)
    COMMA           reduce using rule 88 (var_name -> IDENT LBRACKET expression RBRACKET .)


state 151

    (48) while_statement -> WHILE while_act1 condition while_act2 DO . statement
    (31) statement -> . assignment_statement
    (32) statement -> . if_statement
    (33) statement -> . while_statement
    (34) statement -> . for_statement
    (35) statement -> . proc_call_statement
    (36) statement -> . null_statement
    (37) statement -> . block_statement
    (38) statement -> . read_statement
    (39) statement -> . write_statement
    (40) statement -> . func_call_statement
    (41) assignment_statement -> . IDENT ASSIGN expression
    (42) assignment_statement -> . IDENT LBRACKET expression RBRACKET ASSIGN expression
    (43) if_statement -> . IF condition if_act1 THEN statement else_statement
    (48) while_statement -> . WHILE while_act1 condition while_act2 DO statement
    (51) for_statement -> . FOR IDENT ASSIGN expression TO expression for_act1 DO statement
    (53) proc_call_statement -> . proc_call_name LPAREN RPAREN
    (54) proc_call_statement -> . proc_call_name LPAREN proc_call_statement_act1 arg_list RPAREN
    (67) null_statement -> .
    (63) block_statement -> . BEGIN statement_list END
    (64) read_statement -> . READ LPAREN IDENT RPAREN
    (65) read_statement -> . READ LPAREN IDENT LBRACKET expression RBRACKET RPAREN
    (66) write_statement -> . WRITE LPAREN expression RPAREN
    (56) func_call_statement -> . func_call_name LPAREN RPAREN
    (57) func_call_statement -> . func_call_name LPAREN func_call_statement_act1 arg_list RPAREN
    (61) proc_call_name -> . IDENT
    (62) func_call_name -> . IDENT

    IDENT           shift and go to state 41
    IF              shift and go to state 42
    WHILE           shift and go to state 43
    FOR             shift and go to state 44
    ELSE            reduce using rule 67 (null_statement -> .)
    PERIOD          reduce using rule 67 (null_statement -> .)
    END             reduce using rule 67 (null_statement -> .)
    SEMICOLON       reduce using rule 67 (null_statement -> .)
    BEGIN           shift and go to state 46
    READ            shift and go to state 47
    WRITE           shift and go to state 48

    statement                      shift and go to state 166
    assignment_statement           shift and go to state 31
    if_statement                   shift and go to state 32
    while_statement                shift and go to state 33
    for_statement                  shift and go to state 34
    proc_call_statement            shift and go to state 35
    null_statement                 shift and go to state 36
    block_statement                shift and go to state 37
    read_statement                 shift and go to state 38
    write_statement                shift and go to state 39
    func_call_statement            shift and go to state 40
    proc_call_name                 shift and go to state 45
    func_call_name                 shift and go to state 49

state 152

    (51) for_statement -> FOR IDENT ASSIGN expression TO . expression for_act1 DO statement
    (74) expression -> . term
    (75) expression -> . MINUS term
    (76) expression -> . expression PLUS term
    (77) expression -> . expression MINUS term
    (78) expression -> . func_call_statement
    (79) term -> . factor
    (80) term -> . term MULT factor
    (81) term -> . term DIV factor
    (82) term -> . func_call_statement
    (56) func_call_statement -> . func_call_name LPAREN RPAREN
    (57) func_call_statement -> . func_call_name LPAREN func_call_statement_act1 arg_list RPAREN
    (83) factor -> . var_name
    (84) factor -> . number
    (85) factor -> . LPAREN expression RPAREN
    (86) factor -> . func_call_statement
    (62) func_call_name -> . IDENT
    (87) var_name -> . IDENT
    (88) var_name -> . IDENT LBRACKET expression RBRACKET
    (89) number -> . NUMBER

    MINUS           shift and go to state 60
    LPAREN          shift and go to state 63
    IDENT           shift and go to state 66
    NUMBER          shift and go to state 67

    expression                     shift and go to state 167
    term                           shift and go to state 59
    func_call_statement            shift and go to state 61
    factor                         shift and go to state 62
    func_call_name                 shift and go to state 49
    var_name                       shift and go to state 64
    number                         shift and go to state 65

state 153

    (54) proc_call_statement -> proc_call_name LPAREN proc_call_statement_act1 arg_list RPAREN .

    PERIOD          reduce using rule 54 (proc_call_statement -> proc_call_name LPAREN proc_call_statement_act1 arg_list RPAREN .)
    END             reduce using rule 54 (proc_call_statement -> proc_call_name LPAREN proc_call_statement_act1 arg_list RPAREN .)
    SEMICOLON       reduce using rule 54 (proc_call_statement -> proc_call_name LPAREN proc_call_statement_act1 arg_list RPAREN .)
    ELSE            reduce using rule 54 (proc_call_statement -> proc_call_name LPAREN proc_call_statement_act1 arg_list RPAREN .)


state 154

    (60) arg_list -> arg_list COMMA . expression
    (74) expression -> . term
    (75) expression -> . MINUS term
    (76) expression -> . expression PLUS term
    (77) expression -> . expression MINUS term
    (78) expression -> . func_call_statement
    (79) term -> . factor
    (80) term -> . term MULT factor
    (81) term -> . term DIV factor
    (82) term -> . func_call_statement
    (56) func_call_statement -> . func_call_name LPAREN RPAREN
    (57) func_call_statement -> . func_call_name LPAREN func_call_statement_act1 arg_list RPAREN
    (83) factor -> . var_name
    (84) factor -> . number
    (85) factor -> . LPAREN expression RPAREN
    (86) factor -> . func_call_statement
    (62) func_call_name -> . IDENT
    (87) var_name -> . IDENT
    (88) var_name -> . IDENT LBRACKET expression RBRACKET
    (89) number -> . NUMBER

    MINUS           shift and go to state 60
    LPAREN          shift and go to state 63
    IDENT           shift and go to state 66
    NUMBER          shift and go to state 67

    expression                     shift and go to state 168
    term                           shift and go to state 59
    func_call_statement            shift and go to state 61
    factor                         shift and go to state 62
    func_call_name                 shift and go to state 49
    var_name                       shift and go to state 64
    number                         shift and go to state 65

state 155

    (65) read_statement -> READ LPAREN IDENT LBRACKET expression . RBRACKET RPAREN
    (76) expression -> expression . PLUS term
    (77) expression -> expression . MINUS term

    RBRACKET        shift and go to state 169
    PLUS            shift and go to state 91
    MINUS           shift and go to state 92


state 156

    (57) func_call_statement -> func_call_name LPAREN func_call_statement_act1 arg_list RPAREN .

    PERIOD          reduce using rule 57 (func_call_statement -> func_call_name LPAREN func_call_statement_act1 arg_list RPAREN .)
    EQ              reduce using rule 57 (func_call_statement -> func_call_name LPAREN func_call_statement_act1 arg_list RPAREN .)
    NEQ             reduce using rule 57 (func_call_statement -> func_call_name LPAREN func_call_statement_act1 arg_list RPAREN .)
    LT              reduce using rule 57 (func_call_statement -> func_call_name LPAREN func_call_statement_act1 arg_list RPAREN .)
    LE              reduce using rule 57 (func_call_statement -> func_call_name LPAREN func_call_statement_act1 arg_list RPAREN .)
    GT              reduce using rule 57 (func_call_statement -> func_call_name LPAREN func_call_statement_act1 arg_list RPAREN .)
    GE              reduce using rule 57 (func_call_statement -> func_call_name LPAREN func_call_statement_act1 arg_list RPAREN .)
    PLUS            reduce using rule 57 (func_call_statement -> func_call_name LPAREN func_call_statement_act1 arg_list RPAREN .)
    MINUS           reduce using rule 57 (func_call_statement -> func_call_name LPAREN func_call_statement_act1 arg_list RPAREN .)
    MULT            reduce using rule 57 (func_call_statement -> func_call_name LPAREN func_call_statement_act1 arg_list RPAREN .)
    DIV             reduce using rule 57 (func_call_statement -> func_call_name LPAREN func_call_statement_act1 arg_list RPAREN .)
    END             reduce using rule 57 (func_call_statement -> func_call_name LPAREN func_call_statement_act1 arg_list RPAREN .)
    SEMICOLON       reduce using rule 57 (func_call_statement -> func_call_name LPAREN func_call_statement_act1 arg_list RPAREN .)
    ELSE            reduce using rule 57 (func_call_statement -> func_call_name LPAREN func_call_statement_act1 arg_list RPAREN .)
    RBRACKET        reduce using rule 57 (func_call_statement -> func_call_name LPAREN func_call_statement_act1 arg_list RPAREN .)
    RPAREN          reduce using rule 57 (func_call_statement -> func_call_name LPAREN func_call_statement_act1 arg_list RPAREN .)
    THEN            reduce using rule 57 (func_call_statement -> func_call_name LPAREN func_call_statement_act1 arg_list RPAREN .)
    DO              reduce using rule 57 (func_call_statement -> func_call_name LPAREN func_call_statement_act1 arg_list RPAREN .)
    TO              reduce using rule 57 (func_call_statement -> func_call_name LPAREN func_call_statement_act1 arg_list RPAREN .)
    COMMA           reduce using rule 57 (func_call_statement -> func_call_name LPAREN func_call_statement_act1 arg_list RPAREN .)


state 157

    (19) inblock -> inblock_act1 var_decl_part . inblock_act2 statement
    (21) inblock_act2 -> .

    IDENT           reduce using rule 21 (inblock_act2 -> .)
    IF              reduce using rule 21 (inblock_act2 -> .)
    WHILE           reduce using rule 21 (inblock_act2 -> .)
    FOR             reduce using rule 21 (inblock_act2 -> .)
    BEGIN           reduce using rule 21 (inblock_act2 -> .)
    READ            reduce using rule 21 (inblock_act2 -> .)
    WRITE           reduce using rule 21 (inblock_act2 -> .)
    SEMICOLON       reduce using rule 21 (inblock_act2 -> .)

    inblock_act2                   shift and go to state 170

state 158

    (16) proc_decl -> PROCEDURE proc_name LPAREN proc_decl_act1 id_list RPAREN SEMICOLON . inblock
    (19) inblock -> . inblock_act1 var_decl_part inblock_act2 statement
    (20) inblock_act1 -> .

    VAR             reduce using rule 20 (inblock_act1 -> .)
    IDENT           reduce using rule 20 (inblock_act1 -> .)
    IF              reduce using rule 20 (inblock_act1 -> .)
    WHILE           reduce using rule 20 (inblock_act1 -> .)
    FOR             reduce using rule 20 (inblock_act1 -> .)
    BEGIN           reduce using rule 20 (inblock_act1 -> .)
    READ            reduce using rule 20 (inblock_act1 -> .)
    WRITE           reduce using rule 20 (inblock_act1 -> .)
    SEMICOLON       reduce using rule 20 (inblock_act1 -> .)

    inblock                        shift and go to state 171
    inblock_act1                   shift and go to state 141

state 159

    (26) func_inblock -> func_inblock_act1 var_decl_part . func_inblock_act2 statement
    (28) func_inblock_act2 -> .

    IDENT           reduce using rule 28 (func_inblock_act2 -> .)
    IF              reduce using rule 28 (func_inblock_act2 -> .)
    WHILE           reduce using rule 28 (func_inblock_act2 -> .)
    FOR             reduce using rule 28 (func_inblock_act2 -> .)
    BEGIN           reduce using rule 28 (func_inblock_act2 -> .)
    READ            reduce using rule 28 (func_inblock_act2 -> .)
    WRITE           reduce using rule 28 (func_inblock_act2 -> .)
    SEMICOLON       reduce using rule 28 (func_inblock_act2 -> .)

    func_inblock_act2              shift and go to state 172

state 160

    (23) func_decl -> FUNCTION func_name LPAREN func_decl_act1 id_list RPAREN SEMICOLON . func_inblock
    (26) func_inblock -> . func_inblock_act1 var_decl_part func_inblock_act2 statement
    (27) func_inblock_act1 -> .

    VAR             reduce using rule 27 (func_inblock_act1 -> .)
    IDENT           reduce using rule 27 (func_inblock_act1 -> .)
    IF              reduce using rule 27 (func_inblock_act1 -> .)
    WHILE           reduce using rule 27 (func_inblock_act1 -> .)
    FOR             reduce using rule 27 (func_inblock_act1 -> .)
    BEGIN           reduce using rule 27 (func_inblock_act1 -> .)
    READ            reduce using rule 27 (func_inblock_act1 -> .)
    WRITE           reduce using rule 27 (func_inblock_act1 -> .)
    SEMICOLON       reduce using rule 27 (func_inblock_act1 -> .)

    func_inblock                   shift and go to state 173
    func_inblock_act1              shift and go to state 144

state 161

    (92) id_list -> id_list COMMA IDENT LBRACKET NUMBER INTERVAL NUMBER . RBRACKET

    RBRACKET        shift and go to state 174


state 162

    (93) id_list -> IDENT LBRACKET NUMBER INTERVAL NUMBER RBRACKET COMMA . id_list id_list_act1
    (90) id_list -> . IDENT
    (91) id_list -> . id_list COMMA IDENT
    (92) id_list -> . id_list COMMA IDENT LBRACKET NUMBER INTERVAL NUMBER RBRACKET
    (93) id_list -> . IDENT LBRACKET NUMBER INTERVAL NUMBER RBRACKET COMMA id_list id_list_act1

    IDENT           shift and go to state 20

    id_list                        shift and go to state 175

state 163

    (42) assignment_statement -> IDENT LBRACKET expression RBRACKET ASSIGN expression .
    (76) expression -> expression . PLUS term
    (77) expression -> expression . MINUS term

    PERIOD          reduce using rule 42 (assignment_statement -> IDENT LBRACKET expression RBRACKET ASSIGN expression .)
    END             reduce using rule 42 (assignment_statement -> IDENT LBRACKET expression RBRACKET ASSIGN expression .)
    SEMICOLON       reduce using rule 42 (assignment_statement -> IDENT LBRACKET expression RBRACKET ASSIGN expression .)
    ELSE            reduce using rule 42 (assignment_statement -> IDENT LBRACKET expression RBRACKET ASSIGN expression .)
    PLUS            shift and go to state 91
    MINUS           shift and go to state 92


state 164

    (43) if_statement -> IF condition if_act1 THEN statement else_statement .

    PERIOD          reduce using rule 43 (if_statement -> IF condition if_act1 THEN statement else_statement .)
    END             reduce using rule 43 (if_statement -> IF condition if_act1 THEN statement else_statement .)
    SEMICOLON       reduce using rule 43 (if_statement -> IF condition if_act1 THEN statement else_statement .)
    ELSE            reduce using rule 43 (if_statement -> IF condition if_act1 THEN statement else_statement .)


state 165

    (45) else_statement -> ELSE . else_act1 statement
    (47) else_act1 -> .

    IDENT           reduce using rule 47 (else_act1 -> .)
    IF              reduce using rule 47 (else_act1 -> .)
    WHILE           reduce using rule 47 (else_act1 -> .)
    FOR             reduce using rule 47 (else_act1 -> .)
    BEGIN           reduce using rule 47 (else_act1 -> .)
    READ            reduce using rule 47 (else_act1 -> .)
    WRITE           reduce using rule 47 (else_act1 -> .)
    ELSE            reduce using rule 47 (else_act1 -> .)
    PERIOD          reduce using rule 47 (else_act1 -> .)
    END             reduce using rule 47 (else_act1 -> .)
    SEMICOLON       reduce using rule 47 (else_act1 -> .)

    else_act1                      shift and go to state 176

state 166

    (48) while_statement -> WHILE while_act1 condition while_act2 DO statement .

    PERIOD          reduce using rule 48 (while_statement -> WHILE while_act1 condition while_act2 DO statement .)
    END             reduce using rule 48 (while_statement -> WHILE while_act1 condition while_act2 DO statement .)
    SEMICOLON       reduce using rule 48 (while_statement -> WHILE while_act1 condition while_act2 DO statement .)
    ELSE            reduce using rule 48 (while_statement -> WHILE while_act1 condition while_act2 DO statement .)


state 167

    (51) for_statement -> FOR IDENT ASSIGN expression TO expression . for_act1 DO statement
    (76) expression -> expression . PLUS term
    (77) expression -> expression . MINUS term
    (52) for_act1 -> .

    PLUS            shift and go to state 91
    MINUS           shift and go to state 92
    DO              reduce using rule 52 (for_act1 -> .)

    for_act1                       shift and go to state 177

state 168

    (60) arg_list -> arg_list COMMA expression .
    (76) expression -> expression . PLUS term
    (77) expression -> expression . MINUS term

    RPAREN          reduce using rule 60 (arg_list -> arg_list COMMA expression .)
    COMMA           reduce using rule 60 (arg_list -> arg_list COMMA expression .)
    PLUS            shift and go to state 91
    MINUS           shift and go to state 92


state 169

    (65) read_statement -> READ LPAREN IDENT LBRACKET expression RBRACKET . RPAREN

    RPAREN          shift and go to state 178


state 170

    (19) inblock -> inblock_act1 var_decl_part inblock_act2 . statement
    (31) statement -> . assignment_statement
    (32) statement -> . if_statement
    (33) statement -> . while_statement
    (34) statement -> . for_statement
    (35) statement -> . proc_call_statement
    (36) statement -> . null_statement
    (37) statement -> . block_statement
    (38) statement -> . read_statement
    (39) statement -> . write_statement
    (40) statement -> . func_call_statement
    (41) assignment_statement -> . IDENT ASSIGN expression
    (42) assignment_statement -> . IDENT LBRACKET expression RBRACKET ASSIGN expression
    (43) if_statement -> . IF condition if_act1 THEN statement else_statement
    (48) while_statement -> . WHILE while_act1 condition while_act2 DO statement
    (51) for_statement -> . FOR IDENT ASSIGN expression TO expression for_act1 DO statement
    (53) proc_call_statement -> . proc_call_name LPAREN RPAREN
    (54) proc_call_statement -> . proc_call_name LPAREN proc_call_statement_act1 arg_list RPAREN
    (67) null_statement -> .
    (63) block_statement -> . BEGIN statement_list END
    (64) read_statement -> . READ LPAREN IDENT RPAREN
    (65) read_statement -> . READ LPAREN IDENT LBRACKET expression RBRACKET RPAREN
    (66) write_statement -> . WRITE LPAREN expression RPAREN
    (56) func_call_statement -> . func_call_name LPAREN RPAREN
    (57) func_call_statement -> . func_call_name LPAREN func_call_statement_act1 arg_list RPAREN
    (61) proc_call_name -> . IDENT
    (62) func_call_name -> . IDENT

    IDENT           shift and go to state 41
    IF              shift and go to state 42
    WHILE           shift and go to state 43
    FOR             shift and go to state 44
    SEMICOLON       reduce using rule 67 (null_statement -> .)
    BEGIN           shift and go to state 46
    READ            shift and go to state 47
    WRITE           shift and go to state 48

    statement                      shift and go to state 179
    assignment_statement           shift and go to state 31
    if_statement                   shift and go to state 32
    while_statement                shift and go to state 33
    for_statement                  shift and go to state 34
    proc_call_statement            shift and go to state 35
    null_statement                 shift and go to state 36
    block_statement                shift and go to state 37
    read_statement                 shift and go to state 38
    write_statement                shift and go to state 39
    func_call_statement            shift and go to state 40
    proc_call_name                 shift and go to state 45
    func_call_name                 shift and go to state 49

state 171

    (16) proc_decl -> PROCEDURE proc_name LPAREN proc_decl_act1 id_list RPAREN SEMICOLON inblock .

    SEMICOLON       reduce using rule 16 (proc_decl -> PROCEDURE proc_name LPAREN proc_decl_act1 id_list RPAREN SEMICOLON inblock .)


state 172

    (26) func_inblock -> func_inblock_act1 var_decl_part func_inblock_act2 . statement
    (31) statement -> . assignment_statement
    (32) statement -> . if_statement
    (33) statement -> . while_statement
    (34) statement -> . for_statement
    (35) statement -> . proc_call_statement
    (36) statement -> . null_statement
    (37) statement -> . block_statement
    (38) statement -> . read_statement
    (39) statement -> . write_statement
    (40) statement -> . func_call_statement
    (41) assignment_statement -> . IDENT ASSIGN expression
    (42) assignment_statement -> . IDENT LBRACKET expression RBRACKET ASSIGN expression
    (43) if_statement -> . IF condition if_act1 THEN statement else_statement
    (48) while_statement -> . WHILE while_act1 condition while_act2 DO statement
    (51) for_statement -> . FOR IDENT ASSIGN expression TO expression for_act1 DO statement
    (53) proc_call_statement -> . proc_call_name LPAREN RPAREN
    (54) proc_call_statement -> . proc_call_name LPAREN proc_call_statement_act1 arg_list RPAREN
    (67) null_statement -> .
    (63) block_statement -> . BEGIN statement_list END
    (64) read_statement -> . READ LPAREN IDENT RPAREN
    (65) read_statement -> . READ LPAREN IDENT LBRACKET expression RBRACKET RPAREN
    (66) write_statement -> . WRITE LPAREN expression RPAREN
    (56) func_call_statement -> . func_call_name LPAREN RPAREN
    (57) func_call_statement -> . func_call_name LPAREN func_call_statement_act1 arg_list RPAREN
    (61) proc_call_name -> . IDENT
    (62) func_call_name -> . IDENT

    IDENT           shift and go to state 41
    IF              shift and go to state 42
    WHILE           shift and go to state 43
    FOR             shift and go to state 44
    SEMICOLON       reduce using rule 67 (null_statement -> .)
    BEGIN           shift and go to state 46
    READ            shift and go to state 47
    WRITE           shift and go to state 48

    statement                      shift and go to state 180
    assignment_statement           shift and go to state 31
    if_statement                   shift and go to state 32
    while_statement                shift and go to state 33
    for_statement                  shift and go to state 34
    proc_call_statement            shift and go to state 35
    null_statement                 shift and go to state 36
    block_statement                shift and go to state 37
    read_statement                 shift and go to state 38
    write_statement                shift and go to state 39
    func_call_statement            shift and go to state 40
    proc_call_name                 shift and go to state 45
    func_call_name                 shift and go to state 49

state 173

    (23) func_decl -> FUNCTION func_name LPAREN func_decl_act1 id_list RPAREN SEMICOLON func_inblock .

    SEMICOLON       reduce using rule 23 (func_decl -> FUNCTION func_name LPAREN func_decl_act1 id_list RPAREN SEMICOLON func_inblock .)


state 174

    (92) id_list -> id_list COMMA IDENT LBRACKET NUMBER INTERVAL NUMBER RBRACKET .

    COMMA           reduce using rule 92 (id_list -> id_list COMMA IDENT LBRACKET NUMBER INTERVAL NUMBER RBRACKET .)
    SEMICOLON       reduce using rule 92 (id_list -> id_list COMMA IDENT LBRACKET NUMBER INTERVAL NUMBER RBRACKET .)
    RPAREN          reduce using rule 92 (id_list -> id_list COMMA IDENT LBRACKET NUMBER INTERVAL NUMBER RBRACKET .)


state 175

    (93) id_list -> IDENT LBRACKET NUMBER INTERVAL NUMBER RBRACKET COMMA id_list . id_list_act1
    (91) id_list -> id_list . COMMA IDENT
    (92) id_list -> id_list . COMMA IDENT LBRACKET NUMBER INTERVAL NUMBER RBRACKET
    (94) id_list_act1 -> .

  ! shift/reduce conflict for COMMA resolved as shift
    COMMA           shift and go to state 28
    SEMICOLON       reduce using rule 94 (id_list_act1 -> .)
    RPAREN          reduce using rule 94 (id_list_act1 -> .)

  ! COMMA           [ reduce using rule 94 (id_list_act1 -> .) ]

    id_list_act1                   shift and go to state 181

state 176

    (45) else_statement -> ELSE else_act1 . statement
    (31) statement -> . assignment_statement
    (32) statement -> . if_statement
    (33) statement -> . while_statement
    (34) statement -> . for_statement
    (35) statement -> . proc_call_statement
    (36) statement -> . null_statement
    (37) statement -> . block_statement
    (38) statement -> . read_statement
    (39) statement -> . write_statement
    (40) statement -> . func_call_statement
    (41) assignment_statement -> . IDENT ASSIGN expression
    (42) assignment_statement -> . IDENT LBRACKET expression RBRACKET ASSIGN expression
    (43) if_statement -> . IF condition if_act1 THEN statement else_statement
    (48) while_statement -> . WHILE while_act1 condition while_act2 DO statement
    (51) for_statement -> . FOR IDENT ASSIGN expression TO expression for_act1 DO statement
    (53) proc_call_statement -> . proc_call_name LPAREN RPAREN
    (54) proc_call_statement -> . proc_call_name LPAREN proc_call_statement_act1 arg_list RPAREN
    (67) null_statement -> .
    (63) block_statement -> . BEGIN statement_list END
    (64) read_statement -> . READ LPAREN IDENT RPAREN
    (65) read_statement -> . READ LPAREN IDENT LBRACKET expression RBRACKET RPAREN
    (66) write_statement -> . WRITE LPAREN expression RPAREN
    (56) func_call_statement -> . func_call_name LPAREN RPAREN
    (57) func_call_statement -> . func_call_name LPAREN func_call_statement_act1 arg_list RPAREN
    (61) proc_call_name -> . IDENT
    (62) func_call_name -> . IDENT

    IDENT           shift and go to state 41
    IF              shift and go to state 42
    WHILE           shift and go to state 43
    FOR             shift and go to state 44
    ELSE            reduce using rule 67 (null_statement -> .)
    PERIOD          reduce using rule 67 (null_statement -> .)
    END             reduce using rule 67 (null_statement -> .)
    SEMICOLON       reduce using rule 67 (null_statement -> .)
    BEGIN           shift and go to state 46
    READ            shift and go to state 47
    WRITE           shift and go to state 48

    statement                      shift and go to state 182
    assignment_statement           shift and go to state 31
    if_statement                   shift and go to state 32
    while_statement                shift and go to state 33
    for_statement                  shift and go to state 34
    proc_call_statement            shift and go to state 35
    null_statement                 shift and go to state 36
    block_statement                shift and go to state 37
    read_statement                 shift and go to state 38
    write_statement                shift and go to state 39
    func_call_statement            shift and go to state 40
    proc_call_name                 shift and go to state 45
    func_call_name                 shift and go to state 49

state 177

    (51) for_statement -> FOR IDENT ASSIGN expression TO expression for_act1 . DO statement

    DO              shift and go to state 183


state 178

    (65) read_statement -> READ LPAREN IDENT LBRACKET expression RBRACKET RPAREN .

    PERIOD          reduce using rule 65 (read_statement -> READ LPAREN IDENT LBRACKET expression RBRACKET RPAREN .)
    END             reduce using rule 65 (read_statement -> READ LPAREN IDENT LBRACKET expression RBRACKET RPAREN .)
    SEMICOLON       reduce using rule 65 (read_statement -> READ LPAREN IDENT LBRACKET expression RBRACKET RPAREN .)
    ELSE            reduce using rule 65 (read_statement -> READ LPAREN IDENT LBRACKET expression RBRACKET RPAREN .)


state 179

    (19) inblock -> inblock_act1 var_decl_part inblock_act2 statement .

    SEMICOLON       reduce using rule 19 (inblock -> inblock_act1 var_decl_part inblock_act2 statement .)


state 180

    (26) func_inblock -> func_inblock_act1 var_decl_part func_inblock_act2 statement .

    SEMICOLON       reduce using rule 26 (func_inblock -> func_inblock_act1 var_decl_part func_inblock_act2 statement .)


state 181

    (93) id_list -> IDENT LBRACKET NUMBER INTERVAL NUMBER RBRACKET COMMA id_list id_list_act1 .

    COMMA           reduce using rule 93 (id_list -> IDENT LBRACKET NUMBER INTERVAL NUMBER RBRACKET COMMA id_list id_list_act1 .)
    SEMICOLON       reduce using rule 93 (id_list -> IDENT LBRACKET NUMBER INTERVAL NUMBER RBRACKET COMMA id_list id_list_act1 .)
    RPAREN          reduce using rule 93 (id_list -> IDENT LBRACKET NUMBER INTERVAL NUMBER RBRACKET COMMA id_list id_list_act1 .)


state 182

    (45) else_statement -> ELSE else_act1 statement .

    ELSE            reduce using rule 45 (else_statement -> ELSE else_act1 statement .)
    PERIOD          reduce using rule 45 (else_statement -> ELSE else_act1 statement .)
    END             reduce using rule 45 (else_statement -> ELSE else_act1 statement .)
    SEMICOLON       reduce using rule 45 (else_statement -> ELSE else_act1 statement .)


state 183

    (51) for_statement -> FOR IDENT ASSIGN expression TO expression for_act1 DO . statement
    (31) statement -> . assignment_statement
    (32) statement -> . if_statement
    (33) statement -> . while_statement
    (34) statement -> . for_statement
    (35) statement -> . proc_call_statement
    (36) statement -> . null_statement
    (37) statement -> . block_statement
    (38) statement -> . read_statement
    (39) statement -> . write_statement
    (40) statement -> . func_call_statement
    (41) assignment_statement -> . IDENT ASSIGN expression
    (42) assignment_statement -> . IDENT LBRACKET expression RBRACKET ASSIGN expression
    (43) if_statement -> . IF condition if_act1 THEN statement else_statement
    (48) while_statement -> . WHILE while_act1 condition while_act2 DO statement
    (51) for_statement -> . FOR IDENT ASSIGN expression TO expression for_act1 DO statement
    (53) proc_call_statement -> . proc_call_name LPAREN RPAREN
    (54) proc_call_statement -> . proc_call_name LPAREN proc_call_statement_act1 arg_list RPAREN
    (67) null_statement -> .
    (63) block_statement -> . BEGIN statement_list END
    (64) read_statement -> . READ LPAREN IDENT RPAREN
    (65) read_statement -> . READ LPAREN IDENT LBRACKET expression RBRACKET RPAREN
    (66) write_statement -> . WRITE LPAREN expression RPAREN
    (56) func_call_statement -> . func_call_name LPAREN RPAREN
    (57) func_call_statement -> . func_call_name LPAREN func_call_statement_act1 arg_list RPAREN
    (61) proc_call_name -> . IDENT
    (62) func_call_name -> . IDENT

    IDENT           shift and go to state 41
    IF              shift and go to state 42
    WHILE           shift and go to state 43
    FOR             shift and go to state 44
    ELSE            reduce using rule 67 (null_statement -> .)
    PERIOD          reduce using rule 67 (null_statement -> .)
    END             reduce using rule 67 (null_statement -> .)
    SEMICOLON       reduce using rule 67 (null_statement -> .)
    BEGIN           shift and go to state 46
    READ            shift and go to state 47
    WRITE           shift and go to state 48

    statement                      shift and go to state 184
    assignment_statement           shift and go to state 31
    if_statement                   shift and go to state 32
    while_statement                shift and go to state 33
    for_statement                  shift and go to state 34
    proc_call_statement            shift and go to state 35
    null_statement                 shift and go to state 36
    block_statement                shift and go to state 37
    read_statement                 shift and go to state 38
    write_statement                shift and go to state 39
    func_call_statement            shift and go to state 40
    proc_call_name                 shift and go to state 45
    func_call_name                 shift and go to state 49

state 184

    (51) for_statement -> FOR IDENT ASSIGN expression TO expression for_act1 DO statement .

    PERIOD          reduce using rule 51 (for_statement -> FOR IDENT ASSIGN expression TO expression for_act1 DO statement .)
    END             reduce using rule 51 (for_statement -> FOR IDENT ASSIGN expression TO expression for_act1 DO statement .)
    SEMICOLON       reduce using rule 51 (for_statement -> FOR IDENT ASSIGN expression TO expression for_act1 DO statement .)
    ELSE            reduce using rule 51 (for_statement -> FOR IDENT ASSIGN expression TO expression for_act1 DO statement .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ELSE in state 149 resolved as shift
WARNING: shift/reduce conflict for COMMA in state 175 resolved as shift
WARNING: reduce/reduce conflict in state 41 resolved using rule (proc_call_name -> IDENT)
WARNING: rejected rule (func_call_name -> IDENT) in state 41
WARNING: reduce/reduce conflict in state 61 resolved using rule (expression -> func_call_statement)
WARNING: rejected rule (term -> func_call_statement) in state 61
WARNING: reduce/reduce conflict in state 61 resolved using rule (term -> func_call_statement)
WARNING: rejected rule (factor -> func_call_statement) in state 61
WARNING: reduce/reduce conflict in state 61 resolved using rule (expression -> func_call_statement)
WARNING: rejected rule (factor -> func_call_statement) in state 61
WARNING: reduce/reduce conflict in state 96 resolved using rule (term -> func_call_statement)
WARNING: rejected rule (factor -> func_call_statement) in state 96
